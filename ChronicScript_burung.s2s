'20100427   DPK     Creating new Chronic Script that is Modular and easier to use
'20140404   DPK     Modifying chronic code to run acute experiments on Burung
'                    There are a number of bits I've hacked together to make this work . look for BURUNGHACK to find them and fix them
'TODO fix interrupt error
'TODO fix setlist error
'FLAG REGISTRY: qhWaitingToJump%,qhWaitingToStartTrial%,qhInTrial%,qhWaitingForStimFinish%,qhWaitingForTrialFinish%,qhFinishTrial%,qhBehavOnly%,qhRecordingAndBehavior%,qhRecordingOnly%
'
#include "F:\code\github\spike2_scripts\chronic\include\chron_include.s2s"

StartupScript();
'
'********************************************
'****** START: SETUP GLOBAL VARIABLES  ******
'********************************************
'
if 1 then 'This lets us fold away the variable set up for ease of viewing while editing!
	
	const VERBOSELOG% := 0;  '1 = normal debugging; 2= time/filesize debugging; ; 3= handler flag debugging
	var ltime%:=-1;
	'
	'+++++++++++++++
	'***scriptvars***
	'set IDs for toolbar buttons
	const HANDLERID% 			:= 0;
	const FINISHEXPERIMENTID%	:= 1;
	
	const PAUSEBLOCKID% 		:= 3;
	const STOPBLOCKID% 			:= 4;
	
	const LOOPSEARCHID%			:= 7;
	
	const CHOOSESEARCHID%		:= 8;
	
	const STOPRECID% 	        := 12;
	const ADJGAINSID% 			:= 13;
	const RESTRTSOMECHANSID% 	:= 14;
	const STARTEPOCHID% 		:= 15;
	
	const QUICKSTART1ID%		:= 17;
	
	const SELECTACTIVESTIMSID% 	:= 30;
	
	const CLOSEOPCHECKWINID%    := 34;
	const CHECKOPERANTDATAID%	:= 35;
	
	const CARCANCELID%			:= 37;
	const CARID%				:= 38;
	const SOFTREFID%			:= 39;
	const SESVIEWID%			:= 40;
	'***done: scriptvars***
	'+++++++++++++++
	'***pathvars***
	const defaultFPS% := 2; '1=use testchron, 2=use crappy windows dialogue, 3=let user type in name of folder in c:/experiments/
	const expPathRoot$      := "F:\\Experiments\\raw\\";
	const stimLibPath$      := "F:\\Experiments\\stimlib\\";
	const chronNOseq$       := "F:\\code\\github\\spike2_scripts\\chronic\\sequencer\\chron_seq_NeurOnly.pls";
	const chronNBseq2AC$    := "F:\\code\\github\\spike2_scripts\\chronic\\sequencer\\chron_seq_2ac_wcue.pls";
	const chronNBseq2ACPS$  := "F:\\code\\github\\spike2_scripts\\chronic\\sequencer\\chron_seq_2ac-peckstop.pls";
	const chronNBseqGNG$    := "F:\\code\\github\\spike2_scripts\\chronic\\sequencer\\chron_seq_gng.pls";
	const chronNBseqGNGPS$  := "F:\\code\\github\\spike2_scripts\\chronic\\sequencer\\chron_seq_gng-peckstop.pls";
	var chronNBseq$ := chronNOseq$; '2ac is default (see DoSubjectInfo%() for switch)
	var seqfile$;
    'BE CAREFEUL: the sample optimise us per time unit options interact with the sequencer files
    var BOsampoptuslow% := 1; 'behavior only
    var BOsampoptushigh% := 10; 'behavior only
    var NONBsampoptuslow% := 1; 'neural included
    var NONBsampoptushigh% := 20; 'neural included
	' 
	var subjectpath$ := "";
	subjectpath$ := PickSubjectPath$(defaultFPS%);
	
    var datafileextension$;
    if App(-1) > 799 then
        datafileextension$ := ".smrx"; ' ".smr" Spike2V7 ;' ".smrx" Spike2V8
    else
        datafileextension$ := ".smr"; ' ".smr" Spike2V7 ;' ".smrx" Spike2V8
	endif
    '
	FilePathSet(subjectpath$);
	PrintLog("Subject path (and current path) set to: %s\n\n", subjectpath$);
	var stimPath$		:= subjectpath$+"stims\\";
	var dataPathRoot$ 	:= subjectpath$+"data\\";
	var dataPathPenetration$,dataPathRecordingSite$,dataPathEpoch$;
	var subjectID$	 	:=Left$(Right$(subjectpath$,Len(subjectpath$)-19),Len(Right$(subjectpath$,Len(subjectpath$)-19))-1); 'TODO: fix and make robust to changes in path length
	'***done: pathvars***
	'+++++++++++++++
	'***filevars***
	const NUMMAXIMUMTICKS% := 2147483647; 'Maximum number of file time ticks possible (see Spike2 manual 4-9)
	const MAXCHANSPERFILE% 		:= 200; 'default is 32, max for spike 6 is 400
	const MAXFILEMINS%			:= -1; 'set to <0 if you want to programmatically control based on sampling frequency etc. See CheckFileSizeLengthNTOD%()
	'const MAXFILEMINS%			:= 15; 'set to <0 if you want to programmatically control based on sampling frequency etc. See CheckFileSizeLengthNTOD%()
	const audioPWAKey$          := "a"; 'this is label for play wave area.
	const trialAvailKeyCue$     := "S"; 'this jumps the sequencer to a place where it is ready to do a trial and turns on the cue light
	const trialPauseKey$        := "P"; 'this jumps the sequencer to a place where it is Paused
	const trialNightNightKey$   := "N"; 'this jumps the sequencer to shut off the operant apparatus and halt the sequencer
	const trialResetKey$        := "R"; 'this jumps the sequencer to turn all outputs off except the house light
	var firsttimestampcodes%[4],timestampcodes%[4];
	ArrConst(firsttimestampcodes%[],243); 'this will be the unique code for the first timestamp on the textmark channel
	ArrConst(timestampcodes%[],244); 'this will be the unique code for timestamps on the textmark channel
	var once%:=1; 'I think this is for the first trial only (TODO: check this and rename with more descriptive name)
	'***done: filevars***
	'+++++++++++++++
	'+++++++++++++++
	'***ADCvars***
	const MAXWAVCHANS%			:= 48;
	'
	var nWavChans%;
	var savedWFChans%[MAXWAVCHANS%+1];
	var currChanMap%[MAXWAVCHANS%+4]; '+1 for size at index 0 and +3 for crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	var swc%;
    
    var type1401% := 7; 'need to change this depending on which 1401 we use '4 for manu '5 for chronic rig '7 for burung 'BURUNGHACK    
    
	var GainList$[4];
	GainList$[0] := "1";
	GainList$[1] := "2";
	GainList$[2] := "5";
	GainList$[3] := "10";
	var whichGainCtrl% 			:= 3; 'This value will be the DEFAULT See AdjustGains%, 0=1x, 1=2x, 2=5x, 3=10x (given by GainList$)
	'
	'var sampleRate%         	:= 18975; 'this is overkill, hardware filter set at 300Hz-8000Hz '18975 works well for 17wf chans, lets record for ~1:50
	'var sampleRate%         	:= 25000;
    '	var sampleRate%         	:= 31250;
    var sampleRate%         	:= 20000;    
	var BehavOnlysampleRate%    := 40000; 'To record BOS/whatever else is going on in box (40K might be too high, but can easily delete Behav only waveform chans if no bos on em
	var usecpertime;
	var timeperADC;
	var seqPerMs;
	'done: ***ADCvars***
	'+++++++++++++++
	'***audioIOvars***
	'const REQUESTEDaudioOutRate%          := 44100; 'The actual rate will be 43859.649123 (corresponding to an output interval of 22.8 uSec, a hardware limitation).
	'(The hardware can only output intervals that are a multiple of 0.2usec) Instead of dealing with this all, I've decided to resample all of my stimuli to 
	'40,000Hz before Spike2 ever sees them. As this corresponds to an exact integer interval (25usec), there should be no problem at all in reading it into Spike2, 
	'playing it back at the desired rate, and reading it into Matlab later. Spike2 could really use some better documentation about this.
	const REQUESTEDaudioOutRate%          := 40000;
	if REQUESTEDaudioOutRate% <> 40000 then
		WarnDlg("REQUESTEDaudioOutRate == %d NOT 40000","REQUESTEDaudioOutRate == %d NOT 40000");
	endif
	'
	var REALaudioOutRate; 'This will hold the value returned by PlayWaveSpeed()
	'
	var maxStimMins%			:= 10; 'only used to constrain the buffer size.
	''''^Limit of Power 1401 with 256Mb RAM (ChronicRig) @ 44100Hz is around 18 mins. If over, script will crash on 'PlayWaveCopy' and you will need to restart spike2, not just the script, to fix it.
	if maxStimMins% > 18 then
		WarnDlg("Play wave buffer set too large.",Print$("You requested a %d min buffer.\nThe empirical limit is 18 mins. Don't ask why, I don't know.\nResetting to 18 min audout buffer.",maxStimMins%));
		maxStimMins%:=18;
	endif
	'
	var audBuffSize%				:= REQUESTEDaudioOutRate%*60*maxStimMins%; 'in sampling units
	var stimsz%; 'get from chandata, use to calc exact time to send to sequencer to give exact num dat points
	var stimtimeSec; 'calc from stimsz% and REALaudioOutRate to calc seq steps to send to sequencer
	'
	var BOmicport% := 7;   'BURUNGHACK   
	var BOmicchannel% := 25;
	var dosavemicchannelduringBO% := 0; 'if this is set to 1, port 31 is recorded and saved along with the marker data (default is 0 to save disk space) 
	'***done: audioIOvars***
	'+++++++++++++++
	'***displayandhandlevars***
	var swXLow:=1.0, swYLow:=0.0,swXHigh:=100.0,swYHigh:=100.0;
	var ymin[MAXWAVCHANS%+1], ymax[MAXWAVCHANS%+1];
	ArrConst(ymin, -1.0);ArrConst(ymax, 1.0);
	var optimizey% :=0;
	var lastEpochView$ := "";
	'
	var datahandle%;
	'
	var opDatHandle%:=-1;
	var opDatName$:="";
	'
	var doAllTrialsFile% := 1;
	var AllTrialsHandle%:=-1;
	var AllTrialsName$:= subjectpath$+subjectID$+".AllTrials";
	'
	var subjectInfoName$:=subjectpath$+subjectID$+".SubjectInfo";
	var subjectInfoHandle% := -1;
	'
	var currWFChan%[17],currVChan%[17],currCARChan%[17];
	currCARChan%[0]:=0;
	var numCARs%:=0;
	'***done: displayandhandlevars***
	'+++++++++++++++
	'***timeofdayvars***
	'Setup TOD (time of day) loop variables
	var dontuseTODStartStop% := 0;
	var secondsSinceMinute%,minutessincemidnight%;
	var beginHours%:= 8;
	var beginMins%:=10;
	var endHours%:= 18;
	var endMins%:=55;
	var beginningOfDayInminutessincemidnight% := beginHours%*60 + beginMins%;
	var endOfDayInminutessincemidnight%;
	if dontuseTODStartStop% = 1 then
		endOfDayInminutessincemidnight% := 9999; 'The day will never end!!!
	else
		endOfDayInminutessincemidnight% := endHours%*60 + endMins%;
	endif
	var qisNight% := 0;
	var wentToSleep%:=0;
	'end TOD loop setup
	PrintLog("\nStart of Day Time: %d:%d.\nEnd of Day Time: %d:%d\n\n\n",beginHours%,beginMins%,endHours%,endMins%); 'put here in case cancel button is hit on setupsubjectpath
	'***done: timeofdayvars***
	'+++++++++++++++
	'***fileinfovars***
	var fDate$      :=Date$(2,2,1,1,"-"); 
	var fTime$      :=Time$(1,7,0,":");
	var FileInfo$   := "Date:"+fDate$+"Time:"+fTime$; 'fileinfo$ will be inserted into the file comments using filecomment$()
	'***done: fileinfovars***
	'+++++++++++++++
	'***penetrationvars***
	var penetrationInfo$ := "Null";
	var penetrationNum%;
	var currpencomments$ := "";
	'***done: penetrationvars***
	'+++++++++++++++
	'***electrodevars***
	var electrodeInfo$ := "Null";
	var currElectrode$ := "";
	var infoFileTrodeType%;
	var trodeType%;
	var eTrodeList$[10];
	eTrodeList$[0]:="16 - 2x2 tetrode (F16) - NeuroNexus";
	eTrodeList$[1]:="16 - 1x16 singles (F16) - NeuroNexus";
	eTrodeList$[2]:="32 - 2x16 singles - NeuroNexus";
	eTrodeList$[3]:="1  - single Platinum Iridium - GentnerCo.";
	eTrodeList$[4]:="1 to 1 (16) - Chan # matches port #";
	eTrodeList$[5]:="1 to 1 (32) - Chan # matches port #";
	eTrodeList$[6]:="24 - 1x16 singles + LFP - NeuroNexus";
	eTrodeList$[7]:="16 - 1x16 singles (H16) - NeuroNexus";
	eTrodeList$[8]:="32 - 1x32 singles (A32) - NeuroNexus"; 
	eTrodeList$[9]:="32 - 4x8 N-Form - Modular Bionics";
	var eTrodeComments$:="";
	var eTrodeImpedance$:="";
	var eTrodeID$:="";
	'***done: electrodevars***
	'+++++++++++++++
	'***sitevars***
	var recordingSiteInfo$:="Null";
	var recordingSiteNum%;
	var currsitecomments$ := "";
	'***done: sitevars***
	'+++++++++++++++
	'***epochvars***
	var epochInfo$:="Null";
	var epochNum%:=0;
	var currepochcomments$ := "";
	var datafilenumber% := 0;
	var currentEpochStartDateTime$ := "";
	'***done: epochvars***
	'+++++++++++++++
	'***stimvars***
	const MAXSTIMS%             := 1000;
	const MAXMCSTIMS%           := 1000000;
	const stimExt$              := ".wav";
	var numStimFiles%, stimFileNames$[maxStims%], searchStimsEnabled%[maxStims%],blockStimsEnabled%[maxStims%],stimTimes[maxStims%];
	var dolongstim%:=0, stimfh%:=-1, startT, stopT, skip;
	var currentStimLength:=0.0, currentStimName$:="",currentStimClass%,currentStimPcntReinf%,currentStimPcntTo%;
	var currStim%:=-1,lastStim%:=-1;
	var maxstimlength;
	var relE,relENO;
	var tmcode%[4]; 'textmark codes: 0=stimcode,1=stimclass,2=correctiontrial(1=correction,0=not correction),3=currently unused
	'{during the MC task, tmcode%[2] used to be used to indicate stimulus type - I think it interferred with correction trial encoding, but I don't think I ever used correction trials so no big deal.}
	ArrConst(tmcode%[],0);
	var stimClasses%[MAXSTIMS%],stimPctPres[maxStims%],stimPctReinf%[maxStims%],stimPctTo%[maxStims%],stimCodes%[maxStims%];
	var totpres%:=0;
	var rndplist%[MAXSTIMS%]; 'Arbitrary length, might need to be bigger if there are really maxStims% number of stims
	var desPctPres[MAXSTIMS%],desPctReinf%[MAXSTIMS%],desPctTo%[MAXSTIMS%];
	ArrConst(desPctPres[],-1.0);
	ArrConst(desPctReinf%[],-1);
	ArrConst(desPctTo%[],-1);
	'***done: stimvars***
	'+++++++++++++++
	'***stimselectionvars***
	const MAXBLOCKTRIALS%       := 10000;
	var blockPlaylist%[MAXBLOCKTRIALS%];
	ArrConst(blockPlaylist%[],-1);
	var numBlockRepeats% := 5;
	const MAXREPEATS%:=999;
	var blockTrialNum%:=0;
	var blockPos%;
	var totBlockTrials%:=0;
	const NUMSHUFFLES%:=99999;
	var blockNum%       := 0;
	var trialFailures%  := 0;
	var totalRunSecs    := 0.0;
	var searchInd%:=-1;
	'***done: stimselectionvars***
	'+++++++++++++++
	'***trialvars***
	var behType$    := "2AC"; 'this should actually be a subject variable
	var RESPWIN     := 2.0;   'response window duration in seconds
	var FEED        := 2.0;		'feed duration in seconds
	var TIMEOUT     := 10.0;	'timeout duration in seconds
	var ITI         := 2.0; 		'intertrial interval in seconds
	var ITINO;
	var MINITINO    := 3.0;  'minimum intertrial interval in seconds for neural recording only
	var MAXITINO    := 5.0; 	'maximum intertrial interval in seconds for neural recording only
	var relS        := -4.0; 	'pretrigger save seconds
	var correctionTrialsOn% := 0; 'default is no correction trials (set in SEsetupStimSelectStyle%()
	var doCorrectionTrial%  := -1;
	var doFeedCorrectionTrials% := 0;
	var peckStopOn%         := 0;
	var currtrialstarttime := -1.0;
	var trialoutcome%[5];  '0 = accuracy, 1 = class , 2 = correction, 3 = selection, 4 = reinforced
	ArrConst(trialoutcome%,-1);
	'***done: trialvars***
	'+++++++++++++++
	'***trialschedulingvars***
	var qTrialAvailability% := 1;        '0 = trials unavailable, 1 = trials available
	var trialAvailablityMins%[2];
	trialAvailablityMins%[0] := 0;        'off minutes
	trialAvailablityMins%[1] := 99999;    'on minutes
	var lastAvailabilityCycleStartMSM% := -1; 'will denote the time (in minutes since midnight) of the last trial availability cycle start time
	'***done: trialschedulingvars***
	'+++++++++++++++
	'***protocolvars***
	var protocoltype$ := "normal";
	var protocolmode% := -1; 'initialized to -1 so that if the protocol doesn't update it, it gets passed to PickMode()
	var protocolstimselectionstyle% := -1;
	var protFileName$;
	var protFileFullName$ := "none";
	var stimFileName$;
	var stimFileFullName$ := "";
	'***done: protocolvars***
	'+++++++++++++++
	'***setstimvars***
	var qdosetstims% := 0;
	var qneednewset%:=-1;
	var qusepreviousset%:=-1;
	var numsetstimclasses% := 6;
	var ssCriterionLength% := 20;	
	var ssCriterionCorrect%[1];
	resize ssCriterionCorrect%[numsetstimclasses%+1];
	ssCriterionCorrect%[0] := 6;
	ssCriterionCorrect%[1] := 15;
	ssCriterionCorrect%[2] := 15;
	ssCriterionCorrect%[3] := 0;
	ssCriterionCorrect%[4] := 0;
	ssCriterionCorrect%[5] := 15;
	ssCriterionCorrect%[6] := 15;
	var ssCriterionReached%[1];
	resize ssCriterionReached%[numsetstimclasses%+1];
	ssCriterionReached%[0] := numsetstimclasses%;
	ssCriterionReached%[1] := 0;
	ssCriterionReached%[2] := 0;
	ssCriterionReached%[3] := 0;
	ssCriterionReached%[4] := 0;
	ssCriterionReached%[5] := 0;
	ssCriterionReached%[6] := 0;
	var lastNIndex%[1];
	resize lastNIndex%[numsetstimclasses%+1];
	var lastN%[1][1];
	resize lastN%[numsetstimclasses%+1][ssCriterionLength%];
	ArrConst(lastN%[][],0);
	var ssnumsets%[3];
	ArrConst(ssnumsets%[],1);
	var mastersetstimfile$ := "nomastersetstimfile";
	var currsetstimfile$ := "nocurrsetstimfile";
	var numfoundcurrsetstimfiles%:=0;
	var foundcurrsetstimfiles$[100];
	var currsetstimparamsfile$ := "D:\\experiments\\stimlib\\defaultsetstimsparamsfile.m";
	var mastersetstimNum%:=0;
	var setstimNum%:=0;
	'***done: setstimvars***
	'+++++++++++++++
	'***MCstimvars***
	var qMC% := 0;
	var MCmaxnummots%:=0,MCminnummots%:=0;
	var MCclassoneMaxnummots%:=0,MCclassonePctReinf%:=0,MCclassonePctTo%:=0;
	var MCclasstwoMaxnummots%:=0,MCclasstwoPctReinf%:=0,MCclasstwoPctTo%:=0;
	var MCclassthreeMaxnummots%:=0,MCclassthreePctReinf%:=0,MCclassthreePctTo%:=0;
	var MCallowLR%:=0;
	var MCallowambig%:=0;
	var MCtotnum%:=0;
	var MCstimClasses%[MAXMCSTIMS%];   'This will hold the class of each created MC stim (aligns with MCstimFilenames$)
	var MCstimFilenames$[MAXMCSTIMS%];
	var MCnumMots%[MAXMCSTIMS%];
	'***done: MCstimvars***
	'+++++++++++++++
	'***analysis/checkvars***
	var tempdatafilename$,tempdatafilepath$;
	var currSeekTime        := -1;
	var lastEventTime       := -1;
	var lastTrialEndTime    := -0.5;
	var lastSizeCheckTime   := -1;
	var secondsBTSizeChecks := 30; 'Set this to a reasonable number.  
	'secondsBTSizeChecks - if too big will slow down the code, too little and you might miss going over the size limit
	'w/17 wf channels @25Khz, 10 mins ~500Mb, therefore checking size every 30 seconds should give ~25Mb resolution
	var opData%[MAXSTIMS%][6]; 'Each row is a diff stim, columns are: num presentations, num correct, num feeds, num incorrect, num TOS, num no responses
	'***done: analysis/checkvars***
	'+++++++++++++++
	'***flagvars***
	'flag variables, I'll denote with a prefixed 'q' and wikicaps
	var qSearching%         := 0;
	var qLoop%              := 0;
	var qNeedNewBlock%        := 0;
	var qDoBlocks%           := 0;
	var qAskUserBlockParams% := 1;
	var qSelectRandly%      := 0;
	var qPausedBlock%       := 0;
	var qStopBlock%         := 0;
	var qProtocolFileSetup%  := 0;
	'
	'handlerstuff, prefix ='qh'
	var qhRecordingAndBehavior% := 0;
	var qhRecordingOnly%        := 0;
	var qhBehavOnly%            := 0;
	'
	var qhInTrial%				:= 0;
	var qhInEpoch%				:= 0;
	
	var qhWaitingToJump%        := 0;
	var qhWaitingToStartTrial%  := 0;
	var qhWaitingForStimFinish% := 0;
	var qhWaitingForTrialFinish%:= 0;
	var qhFinishTrial%          := 0;
	'***done: flagvars***
	'+++++++++++++++
	'
endif
'
'********************************************
'****** END:   SETUP GLOBAL VARIABLES  ******
'********************************************
'
'
'********************************************
'****** START: RUN THE SCRIPT      **********
'********************************************
'
FilePathSet(dataPathRoot$,0,1);
SetupToolbar();
ToolbarState("WaitInToolbar");
PL("Entering Toolbar");
Toolbar("toolbar running",1+2+4+8+16+32+64+128+256+512,0);
PL("Exiting Toolbar");
halt; 'the script is finished
'
'********************************************
'****** END:   RUN THE SCRIPT      **********
'********************************************
'
'************************************************************************************************************************************************
'************************************************************************************************************************************************
'************************************************************************************************************************************************
'
'********************************************
'******  FUNCTIONS AND PROCEDURES  **********
'********************************************
'
'=======================================================================================================
'***SETUP FUNCTIONS AND UTILITIES***
'
'
'***SETUP***
proc SetupToolbar()
ToolbarSet(HANDLERID%,"",Handler%);
ToolbarSet(FINISHEXPERIMENTID%,"Finish experiment|0x1b|<esc>",QuitScript%);

ToolbarSet(STOPRECID%,"Stop Recording Epoch||",doStopEpoch%);
ToolbarEnable(STOPRECID%,0);

'ToolbarSet(PAUSEBLOCKID%,"Pause block||",PauseBlock%);
'ToolbarEnable(PAUSEBLOCKID%,0);
'ToolbarSet(STOPBLOCKID%,"Stop block||",doStopBlock%);
'ToolbarEnable(STOPBLOCKID%,0);

'ToolbarSet(LOOPSEARCHID%,"Loop this search stim",doSetLoop%);
'SetLoop(0,0);

'ToolbarSet(CHOOSESEARCHID%,"Choose search stims",ChooseSearchStims%);

ToolbarSet(ADJGAINSID%,"Adjust Gains",doAdjustGains%);
ToolbarEnable(ADJGAINSID%,0);
'ToolbarSet(RESTRTSOMECHANSID%,"Restart w/Subset of Chans",RestartSubsetChans%);
'ToolbarEnable(RESTRTSOMECHANSID%,0);
ToolbarSet(STARTEPOCHID%,"Start Epoch",doStartEpoch%);

ToolbarSet(SELECTACTIVESTIMSID%,"SelectActiveStims",DoSelectActiveStims%);
ToolbarEnable(SELECTACTIVESTIMSID%,0);

ToolbarSet(CHECKOPERANTDATAID%,"Behavior Summary",CheckOpdata%);
ToolbarEnable(CHECKOPERANTDATAID%,0);

ToolbarSet(CLOSEOPCHECKWINID%,"Close Behavior Checks",CloseOperantDataCheckWindows%);
ToolbarEnable(CLOSEOPCHECKWINID%,0);

ToolbarSet(SOFTREFID%,"Setup Software Referencing",SoftRefSetup%);
ToolbarEnable(SOFTREFID%,0);

ToolbarSet(CARID%,"Setup CAR",CARSetup%);
ToolbarEnable(CARID%,0);

ToolbarSet(CARCANCELID%,"Cancel all CARs",CARCancel%);
ToolbarEnable(CARCANCELID%,0);

ToolbarSet(SESVIEWID%,"Load Last View",DoLoadEpcView%);
ToolbarEnable(SESVIEWID%,0);

'ToolbarSet(QUICKSTART1ID%,"QuickNBRPA",QuickNBRPA%); 'TODO: need to update QuickNBRPA% to use infofile etc
'TODO: have separate recording protocol files (diff than stim protocol file...) where we read in all info and just get up and recording?
ToolbarEnable(QUICKSTART1ID%,1);

end
'
func Handler%()  'Anything on the scale of the current script instance
'This is the idle function run by the main script toolbar
if VERBOSELOG%=3 then 
	if SampleStatus() = 2 then
		var s%;
		s% := MaxTime();
		if s% > ltime% + 3 then     'do this roughly every 3 seconds
			ltime% := s%;
			PL("Current Flag Variables:\n");
			PrintLog("qSearching%:\t%d\n",qSearching%);
			PrintLog("qLoop%:\t%d\n",qLoop%);
			PrintLog("qNeedNewBlock%:\t%d\n",qNeedNewBlock%);
			PrintLog("qDoBlocks%:\t%d\n",qDoBlocks%);
			PrintLog("qSelectRandly%:\t%d\n",qSelectRandly%);
			PrintLog("qPausedBlock%:\t%d\n",qPausedBlock%);
			PrintLog("qStopBlock%:\t%d\n",qStopBlock%);
			PrintLog("qProtocolFileSetup%:\t%d\n",qProtocolFileSetup%);
			PrintLog("qhRecordingAndBehavior%:\t%d\n",qhRecordingAndBehavior%);
			PrintLog("qhRecordingOnly%:\t%d\n",qhRecordingOnly%);
			PrintLog("qhBehavOnly%:\t%d\n",qhBehavOnly%);
			PrintLog("qhInTrial%:\t%d\n",qhInTrial%);
			PrintLog("qhInEpoch%:\t%d\n",qhInEpoch%);
			PrintLog("qhWaitingToJump%:\t%d\n",qhWaitingToJump%);
			PrintLog("qhWaitingToStartTrial%:\t%d\n",qhWaitingToStartTrial%);
			PrintLog("qhWaitingForStimFinish%:\t%d\n",qhWaitingForStimFinish%);
			PrintLog("qhWaitingForTrialFinish%:\t%d\n",qhWaitingForTrialFinish%);
			PrintLog("qhFinishTrial%:\t%d\n",qhFinishTrial%);
			PrintLog("\n\n");
		endif
	endif
endif

docase
case qhInTrial% = 1 then 'being in a trial trumps all else - do all the other checks outside of a trial
	return HTrial%();
case HcEpoch%() = 1 then 'should be in an Epoch
	return HEpoch%(); 'return anything but 1 to abort the script
else
	ToolbarText("Click on Start Epoch to...Start a Recording Epoch...");
endcase
return 1;
end
'
func HcEpoch%()    'Hc for 'Handler check'
'if qTrialAvailability% = 0 then 'this means we're in an epoch and we just don't have trials available.
'	return 1;
'else
return qhInEpoch%;
'endif
end
'
func HEpoch%()
'
if HcNight%(beginningOfDayInminutessincemidnight%,endOfDayInminutessincemidnight%) = 1 then 'it is nighttime - no trials available - no datafile open - house lights off
	return HdoNight%();
endif
'
if HcTrialsAvailable%() = 1 then
	return HdoTrials%();
else
	return HdoTrialsoff%();     'turn cue light off etc etc
endif
'
PrintLog("Not sure how you got here, aborting script.\nIn HEpoch%()\n");
return 0'should never get here
'
end
'
func HcNight%(beginningOfDayInminutessincemidnight%,endOfDayInminutessincemidnight%)
TimeDate(secondsSinceMinute%,minutessincemidnight%);
if (minutessincemidnight% > endOfDayInminutessincemidnight%) or (minutessincemidnight% < beginningOfDayInminutessincemidnight%) then
	'we're in the nighttime bit
	qisNight% := 1;
	return 1
else
	qisNight% := 0;
	return 0
endif
end
'
func HdoNight%()
if SampleStatus() = 2 then 'sampling is still happening and so this is the first time we've passed the nighttime check - close down the datafile etc
	lastAvailabilityCycleStartMSM% := -1;
	SampleKey(trialNightNightKey$);
	Yield(5);
	StopRecordingandSave%(0);  'I think this happens before the sequencer gets to shut the light off, adding a pause before this.
	PL(Print$("It's nighttime, waiting for %02d:%02d to restart",beginHours%,beginMins%));
	ToolbarText(Print$("It's nighttime, waiting for %02d:%02d to restart",beginHours%,beginMins%));	
else ' can get here if sampling is off when the bird is in trialsavailable=0 condition, still need to reset stuff for morning.
	lastAvailabilityCycleStartMSM% := -1;
	'PL(Print$("It's nighttime, waiting for %02d:%02d to restart",beginHours%,beginMins%)); 'WOAH THAT MAKES A HUGE TEXTFILE!
	ToolbarText(Print$("It's nighttime, waiting for %02d:%02d to restart",beginHours%,beginMins%));	
	'anything we want to do in here while looping at nighttime? TODO: YES! MAKE SURE LIGHTS ARE OFF!!
endif
return 1
end
'
func HcTrialsAvailable%()
TimeDate(secondsSinceMinute%,minutessincemidnight%);
if lastAvailabilityCycleStartMSM% = -1 then 'the default is to start with a 'trials on' sequence
	lastAvailabilityCycleStartMSM% := minutessincemidnight%;
	qTrialAvailability% := 1;
endif
if minutessincemidnight% >= lastAvailabilityCycleStartMSM% + trialAvailablityMins%[qTrialAvailability%] then  'reset cycle, flip availability
	lastAvailabilityCycleStartMSM% := minutessincemidnight%;
	if qTrialAvailability% = 1 then
		qTrialAvailability% := 0;
		return 0
	else
		PL(Print$("Starting the next TrialsAvailableOn sequence. Trials will continue for the next %d minutes",trialAvailablityMins%[1]));
		qTrialAvailability% := 1;
		return 1;
	endif
else
	return qTrialAvailability%
endif

end
'
func HdoTrialsoff%()
var trialPauseTime; 'don't know if I'll ever need this, but don't forget that it exists
if SampleStatus() = 2 then    'sampling is happening, there is a datafile being written to - pause the sequencer and turn the datafile off!
	PL(Print$("Pausing the sequencer and starting the next TrialsAvailableOff sequence. Trials will restart in %d minutes",trialAvailablityMins%[0]));
	trialPauseTime:=SampleKey(trialPauseKey$);  'this pauses the sequencer (puts it to PTPK section), will unpause when script passes 'S' again
	StopRecordingandSave%(0);
else
	var hHTA%,mHTA%,sHTA%;
	HoursMinsSecs((lastAvailabilityCycleStartMSM% + trialAvailablityMins%[qTrialAvailability%])*60,hHTA%,mHTA%,sHTA%);
	ToolbarText(Print$("Looping in trialsoff, waiting until %02d:%02d",hHTA%,mHTA%));
	'anything we want to do in here while looping in trialsoff?
endif

return 1;
end
'
'
'
'***BEGIN: DoTrial Code***
'
'
func HdoTrials%()
if SampleStatus() <> 2 then   'no sampling happening, so start it!
	if HStartSampling%() <> 1  then
		PL("Data File Setup Failed: Returning to Toolbar");
		ZeroAllFlags();
		ToolbarState("WaitInToolbar");
		return 1;
	else
		return 1;
	endif
else  'already sampling
	return HPreTrial%();
endif

return 1
end
'
func HStartSampling%()
'
var ret%,iIR%,usersView%,chttl$,hchan%,hssSuccess%:=0,retPWSpd;
'var chanspec%[4];
ToolbarState("StartSampling");
'
FilePathSet(dataPathEpoch$);
ret%:=FilePathSet(dataPathEpoch$,1);
if ret%=0 then
    usersView%:=View();
	'
	datahandle%:=FileNew(0,0); 'Main Datafile is created here
    if datahandle%>=0 then 'all went well, set some display options
		'XRange(-1,30);
        SampleAutoFile(0);
        View(datahandle%).DrawMode(-1,14); 'text draw mode??
        View(datahandle%).Draw(0,10);
        View(datahandle%).Window(swXLow,swYLow,swXHigh,swYHigh);
        View(datahandle%).WindowVisible(1);
		FrontView(datahandle%);
		
		if qhBehavOnly% then
			View(datahandle%).WindowTitle$("Sampled Behavioral Data");
			ChanTitle$(30,"stimulus");
            ChanTitle$(25,"Aud. Stim.");
            DrawMode(25, 9, 256, 1, 96, 96, 1, 0);
		else
			View(datahandle%).WindowTitle$("Sampled Data");			
			docase 
			case(trodeType% = 0) then
				for iIR%:=1 to currChanMap%[0] do 
					View(datahandle%).YRange(iIR%,ymin[iIR%],ymax[iIR%]);
					'PrintLog("ymin[%d]:%g \tymax[%d]:%g\n", iIR%, ymin[iIR%], iIR%, ymax[iIR%]);   
					chttl$ := Print$("Port %d", currChanMap%[iIR%]);
					ChanTitle$(iIR%,chttl$);
					if(iIR%<5) then   
						ChanColour(iIR%,1,9);
					else
						if (iIR%<9) then  
							ChanColour(iIR%,1,10);
						else
							if (iIR%<13) then    
								ChanColour(iIR%,1,11);
							else
								ChanColour(iIR%,1,12);
							endif
						endif
					endif
                next;
				ChanTitle$(currChanMap%[0],"Aud. Stim.");
				DrawMode(currChanMap%[0], 9, 256, 1, 96, 96, 1, 0);
			case(trodeType% = 1 or trodeType% = 4 or trodeType% = 6 or trodeType% = 7 or trodeType% = 8) then
				for iIR%:=1 to currChanMap%[0] do 
                    if currChanMap%[iIR%] <> -1 then
                        View(datahandle%).YRange(iIR%,ymin[iIR%],ymax[iIR%]);
                        'PrintLog("ymin[%d]:%g \tymax[%d]:%g\n", iIR%, ymin[iIR%], iIR%, ymax[iIR%]); 
                        chttl$ := Print$("Port %d", currChanMap%[iIR%]);
                        ChanTitle$(iIR%,chttl$);
                    endif
                next;
				ChanTitle$(currChanMap%[0],"Aud. Stim.");
				DrawMode(currChanMap%[0], 9, 256, 1, 96, 96, 1, 0);
			case(trodeType% = 2 or trodeType% = 5) then
				for iIR%:=1 to nWavChans% do 
                    if currChanMap%[iIR%] <> -1 then
                        View(datahandle%).YRange(iIR%,ymin[iIR%],ymax[iIR%]);
                        'PrintLog("ymin[%d]:%g \tymax[%d]:%g\n", iIR%, ymin[iIR%], iIR%, ymax[iIR%]); 
                        chttl$ := Print$("Port %d", currChanMap%[iIR%-1]);
                        ChanTitle$(iIR%,chttl$);
                    endif
                next;
                ChanTitle$(currChanMap%[0],"Aud. Stim.");
				DrawMode(currChanMap%[0], 9, 256, 1, 96, 96, 1, 0);
			case(trodeType% = 3) then
				for iIR%:=1 to nWavChans% do 
                    if currChanMap%[iIR%] <> -1 then
                        View(datahandle%).YRange(iIR%,ymin[iIR%],ymax[iIR%]);
                        'PrintLog("ymin[%d]:%g \tymax[%d]:%g\n", iIR%, ymin[iIR%], iIR%, ymax[iIR%]); 
                        chttl$ := Print$("Port %d", currChanMap%[iIR%-1]);
                        ChanTitle$(iIR%,chttl$);
                    endif
                next;
                ChanTitle$(currChanMap%[0],"Aud. Stim.");
				DrawMode(currChanMap%[0], 9, 256, 1, 96, 96, 1, 0);
			else
				PrintLog("ERROR: Not sure which electrode type is being used. Channels are probably labeled incorrectly. trodeType% is: %d \n",trodeType%)
			endcase
			ChanTitle$(30,"stimulus textmark");
		endif
        'if find resource file to use, apply it
		var epochDirFiles$[10];
		var retFAR%;
		FilePathSet(dataPathEpoch$);
		if FileList(epochDirFiles$[],-1,"epochView.s2r") = 1 then
			retFAR% := FileApplyResource(epochDirFiles$[0]);
		else
			XRange(-1,30);
		endif
		'
        ret% := SampleStart(); 'Actually start sampling here
        if ret%<0 then 
			PrintLog("ERROR: Error starting sampling: %s",Error$(ret%));
		else
			SampleWrite(1); 'write the data to disk
			seqPerMs:=SampleSeqClock(1); 'get sequencer tick period
			PL(Print$("\nSampling was started at %s",FileTime$(1,7,0,":")));
			SampleText(Print$("date_%s_filetime_%f",GetTimeStamp$(),MaxTime()),-1,firsttimestampcodes%[]);
			datafilenumber%+=1;
			once%:=1;
			hssSuccess%:=1;
			'
			tempdatafilepath$ := View(datahandle%).FileName$(1)+View(datahandle%).FileName$(2);
			tempdatafilename$ := View(datahandle%).FileName$(3)+View(datahandle%).FileName$(4);
			PL(Print$("Recording Initialized. Temp datafile: %s",tempdatafilepath$+tempdatafilename$));
			'
			retPWSpd := PlayWaveSpeed(audioPWAKey$,1.0,0,REALaudioOutRate);
			PL(Print$("PlayWaveSpeed() confirms audio playback at %f Hz (REALaudioOutRate)",REALaudioOutRate));
			usecpertime := SampleUsPerTime();
			PL(Print$("SampleUsPerTime() shows %4.2f uspertime, which gives a max file time of %4.2f minutes",usecpertime,NUMMAXIMUMTICKS% * usecpertime * 1.0e-6 / 60.0));
			'
			if not qhBehavOnly% then
                if type1401% = 5 then
                    if VERBOSELOG% then PL(Print$("Attempting to set conditioner gains to %sx",GainList$[whichGainCtrl%])); endif
                    AdjustGains%(whichGainCtrl%); 'default is 10x 
                endif
            endif
			'
			View(datahandle%).CursorNew(0,1); 'Stim start
			View(datahandle%).CursorNew(0,2); 'Stim end
			
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(datahandle%).CursorNew(0,3); 'response
				View(datahandle%).CursorNew(0,4); 'end of response window
			endif;
			View(datahandle%).CursorNew(0,5); 'end of ITI
			View(datahandle%).CursorVisible(-1,0);
			'
			currSeekTime := -0.5;
			lastEventTime := -0.5;
			lastTrialEndTime := -0.5; 'don't need for record only
			'
			if qhRecordingOnly% then
				VAR waitNO := 1.0; 'seconds to wait before starting neural only stim presentation
				Seconds(0);
				While Seconds() < waitNO do 'record a bit of blank space at the beginning of a neural only recording				
					ToolbarText(Print$("Neural Only Recordings will start in %6.2f seconds",waitNO-Seconds()));
					Draw();
				wend;
			endif;
			'
		endif
    else
        PrintLog("\n****\nERROR: Couldn't create new data file.  error is: %s\nReturning to Toolbar.\n****\n\n",Error$(ret%));
		WarnDlg("Couldn't create new data file.","Couldn't create new data file.\nIs the 1401 on?\nDidn't think so, don't worry it happens to the best of us!\nBack to Toolbar.");
	endif;
else	
    PrintLog("ERROR: Failed to create or set the directory to put the data file in.  error is: %s\n",Error$(ret%));
	WarnDlg("ERROR: couldn't set directory","ERROR: Failed to create or set the directory to put the data file in.\nBack to Toolbar.");	
endif;

return hssSuccess%
end
'
'
'************************************************************************************************************************************************
'
'***BEGIN: PreTrial Code***
'
'
func HPreTrial%()
'pick stim, load it, send trial available key to sequencer then wait until bird pecks
var timeSinceLastSizeCheck:=View(datahandle%).Maxtime()-lastSizeCheckTime;
if (timeSinceLastSizeCheck > secondsBTSizeChecks or lastSizeCheckTime = -1) then	'Only check the size once every x minutes
	lastSizeCheckTime := View(datahandle%).MaxTime();
	if CheckOkFileSize%() <> 1 then    'check every n minutes (there is some overhead associated)
		StopRecordingandSave%(0);
		return 1;
	endif
endif
'
if CheckOkFileLength%(MAXFILEMINS%) <> 1 then  'check every loop round handler (while not in a trial)
	StopRecordingandSave%(0);
	return 1;
endif
'
docase
case qhWaitingToJump% = 1 then
	return HWaitingToJump%();
case qhWaitingToStartTrial% = 1 then
	return HWaitingToStartTrial%();'in here, qhInTrial% gets set to 1 and further entrances into the handler get shunted off to HTrial%() 
else
	qhWaitingToJump% := HInitTrial%();
	return 1;
endcase
return 1;

end
'
'
func CheckOkFileSize%()
var maxfilebytes% := 2000000000; '2  GB
var fudge := 0.975;     '50 MB
var currFileSize;
var currhandle%;
'
if SampleStatus() <> 2 then 'sampling's not happening
	PrintLog("ERROR: this function should never be called if not sampling.\nHALTING.");
	return -1;
else
	currhandle% := View();
	View(datahandle%);
	currFileSize := FileSize();
	if VERBOSELOG%=1 then PL(Print$("size of: %s is %d bytes",tempdatafilename$,Ceil(currFileSize)));endif
	if currFileSize > (maxfilebytes%*fudge) then 	'2Gb file size limit - 50Mb fudge factor
		View(currhandle%);		
		return 0;
	else
		View(currhandle%);
		return 1;
	endif
endif
end
'
func CheckOkFileLength%(maxmins%)
var fudge := 0.975;
var maxMinutesPossible := NUMMAXIMUMTICKS% * usecpertime * 1.0e-6 / 60.0;
var maxMinutesDesired := Floor(maxMinutesPossible * fudge);
var currhandle%;
'
if SampleStatus() <> 2 then 'sampling's not happening
	PrintLog("ERROR: this function should never be called if not sampling.\nHALTING.");
	return -1;
else
	currhandle% := View();
	View(datahandle%);
	'Check total file time
	if maxmins% < 0 then 'use programmatic max time (maxMinutesDesired)
		if MaxTime() > maxMinutesDesired*60.0 then
			View(currhandle%);
			return 0;
		else 
			View(currhandle%);
			return 1;
		endif
	else
		if MaxTime() > maxmins%*60.0 then
			View(currhandle%);
			return 0;
		else 
			View(currhandle%);
			return 1;
		endif
	endif          
endif
end
'
func HWaitingToJump%()
if VERBOSELOG%=1 then PL("in: HWaitingToJump%"); endif
var trialAvailableTime; 'don't know if I'll ever need this, but don't forget that it exists
if SampleSeqVar(5)<>1 then 'this is important, keeps script from stepping on sequencer's toes re:feed, TO, ITI dur	
	if VERBOSELOG%=1 then PL("Sending trialAvailKeyCue$ to sequencer."); endif
	trialAvailableTime:=SampleKey(trialAvailKeyCue$);  'this triggers the sequencer to begin looking for a center key peck to begin a trial			               
	qhWaitingToJump%:=0;			
	qhWaitingToStartTrial%:=1;			
endif;
return 1;
end
'
func HWaitingToStartTrial%()
'TODO: check to see if bird is singing - if so, add a DigMark so that triggered recording starts
'
if CheckDigChan%(60) = 1 then ' '60' is the code in the sequencer for starting stim output
	qhInTrial% := 1;
	View(datahandle%).CursorVisible(-1,0); 'reset cursors for new trial
	View(datahandle%).Cursor(1,lastEventTime);
	View(datahandle%).CursorVisible(1,1);
	View(datahandle%).SampleText(Print$("%f",MaxTime()),-1,timestampcodes%[]); 'this has 1sec resolution. To get better resolution, will need to compare time of '<' marker with the time of the start of sampling.
	if VERBOSELOG%=1 then PL("Stimulus playback started."); endif
	'
	SampleText(currentStimName$,-1,tmcode%[]); 'write label to textmark channel
	ToolbarText(Print$("Stim %s playing",currentStimName$));			
	qhWaitingToStartTrial%:=0;
	qhWaitingForTrialFinish%:=1;
	qhInTrial%:=1;
else
	'waiting for the bird to peck - used to have a bunch of checks here, but these should be performed outside of this function
endif;
return 1;
end
'
func HInitTrial%()
var itSuccess%:=0,fn$;
var classFromSeq%,pctnofeedFromSeq,pctnotoFromSeq;
var itiSeqSteps%,timeoutSeqSteps%,feedSeqSteps%,respwinSeqSteps%;
'
FilePathSet(stimPath$);
'reset all currrent stim variables
currentStimLength:=0.0;
currentStimClass%:=-1;
currentStimPcntReinf%:=-1;
currentStimPcntTo%:=-1;
'
currStim%:=SelectNextStim%();
'
docase 
case currStim% = -1 then
    if VERBOSELOG% then PL("Just got back from SelectNextStim%:\tMC stim chosen\n"); endif	
case currStim% = -2 then
    itSuccess% := 2;
	return itSuccess%; 'Block Setup Cancelled
case currStim% < -2 then
    PL("Just got back from SelectNextStim%:\tError Selecting Stim\n");
    PL("in InitTrial()\t:something went wrong loading the stim");
    itSuccess% := 0;    
    return itSuccess%;
endcase
'
if qMC% <> 1 then
    fn$:=stimFileNames$[currStim%];
else
    fn$:=MCstimFilenames$[MCtotnum%];
endif
currentStimLength:=UploadStim(fn$);
FilePathSet(dataPathRoot$);
if currentStimLength>0.0 then
    currentStimName$:=Left$(fn$,InStr(fn$,datafileextension$)-1);
    if qMC% <> 1 then
        currentStimClass%:=stimClasses%[currStim%];
		if doCorrectionTrial% = 1 and doFeedCorrectionTrials% <> 1 then
			currentStimPcntReinf% := 0;
		else
			currentStimPcntReinf%:=stimPctReinf%[currStim%];
		endif
        currentStimPcntTo%:=stimPctTo%[currStim%];
    else
        currentStimClass%:=MCstimClasses%[MCtotnum%];
        docase
        case MCstimClasses%[MCtotnum%] = 1 then
            currentStimPcntReinf%:= MCclassonePctReinf%;
            currentStimPcntTo%:= MCclassonePctTo%;
        case MCstimClasses%[MCtotnum%] = 2 then
            currentStimPcntReinf%:= MCclasstwoPctReinf%;
            currentStimPcntTo%:= MCclasstwoPctTo%;
        case MCstimClasses%[MCtotnum%] = 3 then
            currentStimPcntReinf%:= MCclassthreePctReinf%;
            currentStimPcntTo%:= MCclassthreePctTo%;            
        endcase
    endif
    '	
	if qhBehavOnly% or qhRecordingAndBehavior% then
		itiSeqSteps%:=ITI/seqPerMs*1000; 'number of seq ticks in ITI seconds
	else
		ITINO := rand(MINITINO,MAXITINO-MINITINO); 'pick a random intertrial interval from [MINITINO:MAXITINO]
		itiSeqSteps%:=ITINO/seqPerMs*1000; 'number of seq ticks in ITI seconds
	endif
	'
	SampleSeqVar(4,itiSeqSteps%);'send sequencer itiSeqSteps% 
	feedSeqSteps%:=FEED/seqPerMs*1000; 'should give number of seq ticks in FEED seconds
	SampleSeqVar(11,feedSeqSteps%);'send sequencer feedSeqSteps% 
	timeoutSeqSteps%:=TIMEOUT/seqPerMs*1000; 'should give number of seq ticks in TIMEOUT seconds
	SampleSeqVar(13,timeoutSeqSteps%);'send sequencer timeoutSeqSteps% 
	respwinSeqSteps%:=RESPWIN/seqPerMs*1000; 'should give number of seq ticks in RESPWIN seconds
	SampleSeqVar(20,respwinSeqSteps%);'send sequencer respwinSeqSteps% 
	if VERBOSELOG% then PL("Sequencer Loaded with Operant Variables\n"); endif	
	'
	'update sequencer with current trial's values
	SampleSeqVar(22,GetEffectiveStimClass%(currentStimClass%)); 'set class in sequencer
	setBrandVar(1.0-(currentStimPcntReinf%/100.0),25);'set percent 'no reinforcement' in sequencer   'function in chron_include.s2s that converts a percentage to a variable that BRAND can use
	setBrandVar(1.0-(currentStimPcntTo%/100.0),26);'set percent 'no timeout' in sequencer    'function in chron_include.s2s that converts a percentage to a variable that BRAND can use
	'
	classFromSeq%:=SampleSeqVar(22); 'get class from sequencer
	pctnofeedFromSeq:=SampleSeqVar(25); 'get percent reinforcement in sequencer
	pctnotoFromSeq:=SampleSeqVar(26); 'get percent timeouts in sequencer
	if VERBOSELOG% then PL(Print$("classFromSeq%= %d\t pctnofeedFromSeq = %d\t pctnotoFromSeq = %d",classFromSeq%,pctnofeedFromSeq,pctnotoFromSeq)); endif
	'	
	docase 'TODO: fix trialerrors so that they reset in the right places 'BH needs to be taken into account here
    case qMC% = 1 then
		if qhRecordingAndBehavior% or qhBehavOnly% then
			PL(Print$("Stim %s loaded",currentStimName$));
			ToolbarText(Print$("Random MC Stim Selection... Stim %s loaded, waiting for trial to be initiated. Using Protocol File: %s",currentStimName$,protFileName$));
		else
			if qhRecordingOnly% then
				PL(Print$("Random MC Stim Selection... Stim %s loaded. Using Protocol File: %s",currentStimName$,protFileName$));
			else
				PL("What mode are you in??");
			endif
		endif        
    case qDoBlocks% then
		if qhRecordingAndBehavior% then
			PL(Print$("Running Block... Stim %s loaded for block %d trial %d",currentStimName$,blockNum%,blockPos%+1));
			'var hours%,mins%,secs%;
			'HoursMinsSecs(totalRunSecs*(1.0-((blockPos%+1.0)/totBlockTrials%)),hours%,mins%,secs%); 'totalrunsecs set in select stims
			'PrintLog("blockPos: %d, totBlockTrials%:%d, %g done, %g remaining in block\n",blockPos%,totBlockTrials%, (blockPos%+1.0)/totBlockTrials%,(1.0-((blockPos%+1.0)/totBlockTrials%)));
			'PrintLog("%g secs remaining in block\n",totalRunSecs*(1.0-((blockPos%+1.0)/totBlockTrials%)));
			'ToolbarText(Print$("block %d: on trial %d of %d (%g%% done, approx %02d:%02d:%02d of stims remaining).  %d failures this block.",blockNum%,blockPos%+1,totBlockTrials%,100*(blockPos%+1)/totBlockTrials%,hours%,mins%,secs%,trialFailures%));
			ToolbarText(Print$("Stim %s loaded, waiting for trial to be initiated. In block %d: on trial %d of %d. %d failures this block.",currentStimName$,blockNum%,blockPos%+1,totBlockTrials%,trialFailures%));
		else
			if qhRecordingOnly% then
				PL(Print$("Running Block... Stim %s loaded for block %d trial %d\n",currentStimName$,blockNum%,blockPos%+1));
			else
				PL("What mode are you in??");
			endif
		endif
	case qSearching% then
		if qhRecordingAndBehavior% then
			PL(Print$("Stim %s loaded",currentStimName$));
			ToolbarText(Print$("Searching... Stim %s loaded, waiting for trial to be initiated.",currentStimName$));
		else
			if qhRecordingOnly% then
				PL(Print$("Stim %s",currentStimName$));
			else
				PL("What mode are you in??");
			endif
		endif
	case qSelectRandly% then
		if qhRecordingAndBehavior% or qhBehavOnly% then
			PL(Print$("Stim %s loaded",currentStimName$));
			ToolbarText(Print$("Random Stim Selection... Stim %s loaded, waiting for trial to be initiated. Using Protocol File: %s",currentStimName$,protFileName$));
		else
			if qhRecordingOnly% then
				PL(Print$("Random Stim Selection... Stim %s loaded. Using Protocol File: %s",currentStimName$,protFileName$));
			else
				PL("What mode are you in??");
			endif
		endif
	else
		PL("What kind of stimulus selection are you doing?!");
		ToolbarText("What kind of stimulus selection are you doing?!");
	endcase
    itSuccess%:=1;
else
    PL("in InitTrial()\t:something went wrong loading the stim");
    itSuccess%:=0;
endif;
'
return itSuccess%;
end
'
func GetEffectiveStimClass%(inclass%)
'Currently all odd stimuli will be treated as 'left' by the sequencer, and all even stimuli will be treated as 'right'
var effclass%;

if (inclass% mod 2) = 1 then
	effclass% := 1;
else
	effclass% := 2;
endif

return effclass%;
end
'
'************************************************************************************************************************************************
'
'***BEGIN: InTrial Code***
'
'
func HTrial%()
'waiting for stim finish, waiting for trial finish, finish trial
docase
case qhWaitingForStimFinish% = 1 then
	return HWaitingForStimFinish%();
case qhWaitingForTrialFinish% = 1 then
	return HWaitingForTrialFinish%();'in here, qhInTrial% gets set to 1 and further entrances into the handler get shunted off at the first case in 
case qhFinishTrial% = 1 then
	return HFinishTrial%();	
else
endcase

return 1;
end
'
func HWaitingForStimFinish%()
if CheckDigChan%(62) = 1 or CheckDigChan%(35) = 1 then ' '62' is the code in the sequencer for stopping stim output '35' is for stopping output prematurely
	View(datahandle%).Cursor(2,lastEventTime);
	View(datahandle%).CursorVisible(2,1);
	qhWaitingForStimFinish%:=0;
	qhWaitingForTrialFinish%:=1;
else 
	'Draw();
endif;
return 1;
end
'
func HWaitingForTrialFinish%()
if CheckDigChan%(41) = 1 then ' '41' is the code in the sequencer for end of ITI
	View(datahandle%).Cursor(5,lastEventTime);
	View(datahandle%).CursorVisible(5,1);
	qhWaitingForTrialFinish%:=0;
	qhFinishTrial%:=1;
else
	'Draw();
endif;
return 1;
end
'
func HFinishTrial%()
'                          
UpdateOpDatTrial%(trialoutcome%[]);		
lastTrialEndTime:=View(datahandle%).MaxTime();
'
if doAllTrialsFile% = 1 then
	UpdateAllTrialsFile%(trialoutcome%[]);
endif
'
if qdosetstims% then
	UpdateMasterSetStimFile(trialoutcome%);
	if qhRecordingAndBehavior% or qhBehavOnly% then
		if SSNeedNewStimulusSet%(trialoutcome%[],ssCriterionCorrect%[],ssCriterionReached%[],lastN%[][],lastNIndex%[]) then
			PL("All criteria reached, bird needs new set. Setting up new set now.");
			UpdateMasterSetStimFileUTtoT();
			InitializeSetStimCriterionVariables();
			qneednewset% := 1;
			if SEsetupStims%() <> 1 then
				PL("New Set setup failed. What do I do now? Halting, I guess");
				halt;
			else
				PL(Print$("New Set setup successful. currsetstimfile: %s",currsetstimfile$));
			endif		
		endif
	endif
endif
'
lastStim% := currStim%;

if not qLoop% then
	currStim%:=-1 'resets curr stim, to force a new one to be chosen
endif;
'
if qStopBlock% = 1 or qStopBlock% = 2 then			
	StopBlock%();
else
	
endif
'
qhInTrial% := 0;
qhFinishTrial% := 0;
return 1;
end
'
'
'***END: InTrial Code***
'
'
'************************************************************************************************************************************************
'************************************************************************************************************************************************
'************************************************************************************************************************************************
'
'=======================================================================================================
'*******#BEGIN# TOOLBAR BUTTON FUNCTIONS*******
'
func doStartEpoch%()
qhInEpoch% := StartEpoch%();
return 1
end
'
func doAdjustGains%()
AdjustGains%(-1);
return 1;
end
'
func AdjustGains%(whichGain%)
var currPort%, src$[20],retCSL%,retCS%,retCG%;
var port%, in%, gain, offs, low, hi, notch%, ac%;
var desiredGain%,retAGlg%,agSuccess%:=1;

if whichGain% = -1 then
	DlgCreate("Pick gain setting to apply to all channels.",30,.1,0,4,-1,0);
	DlgText("Pick Gain Setting:",0,1);
	DlgList(1,10,GainList$[],10,2,2);
	retAGlg% := DlgShow(whichGain%);
	if retAGlg% = 0 then
		return 1;
	endif
endif

docase
case whichGain%=0 then	
	desiredGain%:=1;
case whichGain%=1 then	
	desiredGain%:=2;
case whichGain%=2 then	
	desiredGain%:=5;
case whichGain%=3 then	
	desiredGain%:=10;
else
	WarnDlg("Error Setting Conditioner Gain Settings","Error Setting Conditioner Gain Settings\nWhichGain is not in the range [0,3].\nSetting gain to 1.");
	desiredGain%:=1;	
endcase
'
for currPort%:=0 to currChanMap%[0]-1 do 'WARNING: careful this only works if the last port is what the stimulus is being recorded on
	retCSL%:=CondSourceList(currPort%,src$[]);	
	retCS%:=CondSet(currPort%,0,desiredGain%,0);
	retCG%:=CondGet(port%, in%, gain, offs, low, hi, notch%, ac%);
	if retCSL%<0 or retCS%<0 or retCG%<0 then
		PL(Print$("attempted to change conditioner gain settings for port %d, there was an error",currPort%));
		WarnDlg("Error Setting Conditioner Gain Settings",Print$("Error Setting Conditioner Gain Settings for port %d",currPort%));
		agSuccess% := 0;
	else
		if VERBOSELOG%=1 then PL(Print$("Conditioner Gain on port %d Set to %d",currPort%,desiredGain%)); endif
	endif;
next

'if trodeType% = 0 or trodeType% = 1 or trodeType% = 4 then 'if recording 16 channels, this sets port 16 (stim input) to 1x gain
'	retCSL%:=CondSourceList(16,src$[]);	
'	retCS%:=CondSet(16,0,1,0);
'	retCG%:=CondGet(port%, in%, gain, offs, low, hi, notch%, ac%);
'	if retCSL%<0 or retCS%<0 or retCG%<0 then
'		PL(Print$("attempted to change conditioner gain settings for port %d, there was an error",currPort%));
'		WarnDlg("Error Setting Conditioner Gain Settings",Print$("Error Setting Conditioner Gain Settings for port %d",currPort%));
'		agSuccess% := 0;
'	else
'		if VERBOSELOG%=1 then PL(Print$("Conditioner Gain on port %d Set to %d",currPort%,desiredGain%)); endif
'	endif;
'endif

if trodeType% = 6 then 'this sets LFP channels to 2x gain
	PL("setting LFP channels (ports 16-23) to 2x gain");
    for currPort% := 24 to 30 do 
        retCSL%:=CondSourceList(currPort%,src$[]);	
        retCS%:=CondSet(currPort%,0,2,0);
        retCG%:=CondGet(port%, in%, gain, offs, low, hi, notch%, ac%);
        if retCSL%<0 or retCS%<0 or retCG%<0 then
            PL(Print$("attempted to change conditioner gain settings for port %d, there was an error",currPort%));
            WarnDlg("Error Setting Conditioner Gain Settings",Print$("Error Setting Conditioner Gain Settings for port %d",currPort%));
            agSuccess% := 0;
        else
            if VERBOSELOG%=1 then PL(Print$("Conditioner Gain on port %d Set to %d",currPort%,desiredGain%)); endif
        endif;
    next
    'now set stim input gain to 2
	retCSL%:=CondSourceList(31,src$[]);	
	retCS%:=CondSet(31,0,2,0);
	retCG%:=CondGet(port%, in%, gain, offs, low, hi, notch%, ac%);
    
endif


if agSuccess% = 1 then
	PL(Print$("conditioner gains on all neural ports set from %s to %d",GainList$[whichGainCtrl%],desiredGain%));
	if trodeType% = 0 or trodeType% = 1 or trodeType% = 4 then
		PL("Stim input port (16) set to 1x.");
	endif		
	whichGainCtrl% := whichGain%;	
endif
'
return 1;
end
'
func DoSelectActiveStims%()
var tmprndplist%[MAXSTIMS%];
docase
case qSearching% then
	SelectActiveStims%(searchStimsEnabled%[],"Select Active Search Stims",0);
case qSelectRandly% then 'TODO: needs to be worked on
	'	for i% = 1 to rndplist%[0]
	'		tmprndplist%[i%-1]:=1;
	'	next;
	'SelectActiveStims%(tmprndplist%[],"Select Active Random Selection Stims",0);	
	'	for i% = 1 to rndplist%[0]
	'		tmprndplist%[i%-1]:=1;
	'	next;
	'	
endcase
return 1;
end
'
func doStopEpoch%() 			'toolbar function

DlgCreate("Confirm Stop Sampling",30,.1,0,4,-1,0);
DlgText("Are you sure you want to Stop Sampling?!.\n(No new trials will be setup while this dialogue is active.)",0,2);
DlgButton(0, "Yep. This Recording Epoch is Done.");
DlgButton(1, "Oh Crap! No, Keep Going.");
if DlgShow() = 0 then
	StopRecordingandSave%(1);
	'TODO: here add some info to the log about what experiments were run in the current 'epoch'
	return 2;
else
	return 1;
endif
end
'
func QuitScript%()
var toReturn%;
DlgCreate("Finish experiment?",83,1,0,4,-1,0);
DlgText("Are you sure you want to finish the experiment and quit the script?",0,2);
DlgButton(0,"Yes");
DlgButton(1,"No");
if not DlgShow() then
	if SampleStatus() = 2 then
		StopRecordingandSave%(1); '1 forces Epoch Stop
	endif
	
	'TODO: here add some info to the log about what experiments were run in the current 'epoch' of the script running
    PL("Script is done. Log(s) saved. Exiting normally");
    toReturn%:=0;
else
    toReturn%:=1;
endif;
return toReturn%;
end;
'
'*******##END## TOOLBAR BUTTON FUNCTIONS*******
'=======================================================================================================
'
'
'=======================================================================================================
'*******#BEGIN# START EPOCH FUNCTIONS*******
'
'
func StartEpoch%()
'
var currViewSE% := View();
var currPathSE$ := FilePath$();
'
PL("Starting Epoch Setup");
'
SEgetSubjectInfo%(subjectInfoHandle%);   'SE for "StartEpoch"'
'
if SEaskProtocolFile%() then
	PL("SEaskProtocolFile% successful.\n");
else
	WarnDlg("Problem Setting Up Protocol File","Problem Setting Up Protocol File\nEpoch Setup failed.\nReturning to Toolbar.\n");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%	
endif
'
'
if SEpickMode%(protocolmode%) = 3 then	'select behavior only, neural recording only, or behavior and neural recording
	PL("User Cancelled Epoch Setup\nReturning to Toolbar.");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%	
endif
'
if SEsetRecordingLocationInfo%(subjectInfoHandle%) then
	PL("Recording Location Info Set.\n");
else
    PL("Recording Location Info setup failed, returning to the toolbar.\n");
	WarnDlg("Recording Location Info setup failed, returning to the toolbar.","Recording Location Info setup failed, returning to the toolbar.");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%	
endif;
'
if SEsetupStims%() then
	PL("Stimulus setup successful.\n");
else
	PL("There was an error setting up the stimuli.\nReturning to Toolbar.\n");
	WarnDlg("Error in SetupStims","There was an error setting up the stimuli.\nReturning to Toolbar.\n");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%
endif
'
if SEsetupStimSelectStyle%(protocolstimselectionstyle%) then
	PL("Stimulus selection setup successful.\n");
else
	PL("I think someone hit the cancel button on the stimselectionstyle dialog.\nReturning to Toolbar.\n");
	WarnDlg("Error in SEsetupStimSelectStyle%","I think someone hit the cancel button on the stimselectionstyle dialog.\nReturning to Toolbar.\n");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%	
endif
'
if SEdoSamplingConfig%() then
	PL("Sampling Configuration successful.\n");
else
    PL("Sampling Configuration failed, returning to the toolbar.\n");
	WarnDlg("Sampling Configuration failed, returning to the toolbar.","Configuration failed, returning to the toolbar. Check logfile, DoConfig%()");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%	
endif;
'
'TODO: here record all variables pertinent to this epoch, print it to subject info file and to logfile
'diff log file per epoch or per file in epoch?  probably best if it's per epoch
if SEdoEpochInfo%(subjectInfoHandle%) then
	PL("DoEpochInfo successful.\n");
else
	WarnDlg("Something went wrong...","Something went wrong starting a new epoch.\nCheck SEdoEpochInfo%\nReturning to Toolbar.");
	ToolbarState("WaitInToolbar");
	ZeroAllFlags();
	return -1;  'this gets returned to qhInEpoch%	
endif
'
'close info file
View(subjectInfoHandle%);
FileClose();
subjectInfoHandle%:=-1;
'
datafilenumber% := 0;
currentEpochStartDateTime$ := GetTimeStamp$();

View(currViewSE%);
FilePathSet(currPathSE$);
return 1;   'this gets returned to qhInEpoch%

end
'
'
'**********
func SEgetSubjectInfo%(&subjectInfoHandle%)
var currPathDSI$,currViewDSI%,keepreading%:=1;
currPathDSI$:=FilePath$();
currViewDSI%:=View();

subjectInfoHandle%:=FileOpen(subjectInfoName$,8,2);
if subjectInfoHandle% <0 then
	penetrationNum%:=0;
	currPathDSI$:=FilePath$();
	FilePathSet(subjectpath$);
	subjectInfoHandle%:=FileNew(1,0);
	if subjectInfoHandle% <0 then
		WarnDlg("Could not create a subject info file, halting.","Could not create a subject info file, halting.");
		halt;		
	endif
	View(subjectInfoHandle%);
	Print("%s:\tCreated Subject Info File for %s\n",GetTimeStamp$(),subjectID$);
	
	DlgCreate("Specify Behavioral Protocol",30,.1,0,5,-1,0);
	DlgText("Specify Behavioral Protocol",0,2);
	DlgButton(0,"2AC");
	DlgButton(1,"GNG");
	if DlgShow() then
		chronNBseq$ := chronNBseqGNG$;
		behType$ := "GNG";
	else
		chronNBseq$ := chronNBseq2AC$;
		behType$ := "2AC";
	endif
	Print("\"Behavior type\",\"%s\"\n\n",behType$);
	View(subjectInfoHandle%).FileSaveAs(subjectID$+".SubjectInfo",1);
	PrintLog("Behavior type set to:\t",behType$);
	
	subjectInfoName$:=View(subjectInfoHandle%).FileName$(0);
	'
	if qhRecordingAndBehavior% or qhRecordingOnly% then
		DoPenetration%(1,subjectInfoHandle%);
	else
		dataPathRecordingSite$ := dataPathRoot$+"prePenetrationBehaviorOnly\\";
		FilePathSet(dataPathRecordingSite$,0,1);
	endif
else
	penetrationNum% := 0;
	recordingSiteNum% := 0;
	epochNum% := 0;
	mastersetstimNum%:=0;
	setstimNum%:=0;
	PrintLog("using subject info file: %s\n",View(subjectInfoHandle%).FileName$(0));
	FrontView(subjectInfoHandle%);
	var var1$:="",var2$:="",var3$:="",var4%,var5$:=""; '5 reserved for comments
	MoveTo(0,0);
	while  keepreading%>=0  do
		if InStr(var1$,"Behavior type")<>0 then
			behType$ := var2$;
			if InStr(behType$,"2AC")<>0 then
				chronNBseq$ := chronNBseq2AC$;
			else
				if InStr(behType$,"GNG")<>0 then
					chronNBseq$ := chronNBseqGNG$;
				endif
			endif
		endif
		'
		if InStr(var2$,"Penetration")<>0 then
			penetrationInfo$ := var3$;
			penetrationNum% := penetrationNum% + 1;
			recordingSiteNum% := 0; 'reset recording site number for each new penetration
			currpencomments$ := var5$;
		endif
		'
		if InStr(var2$,"Electrode")<>0 then
			electrodeInfo$ := var3$;
			infoFileTrodeType%:= var4%; 'find infoFileTrodeType%
			eTrodeComments$ := var5$;
		endif
		'
		if InStr(var2$,"Site")<>0 then
			recordingSiteInfo$ := var3$;
			recordingSiteNum% := recordingSiteNum%+1;
			epochNum% := 0; 'reset epoch number for each new recording site
			currsitecomments$ := var5$;
		endif
		'
		if InStr(var2$,"Epoch")<>0 then
			epochInfo$ := var3$;
			epochNum% := epochNum%+1;
			'currepochcomments$ := var5$;
		endif
		'		
		if InStr(var2$,"CurrSetStimFile") <> 0 then
			currsetstimfile$ := var3$;
		endif
		
		if InStr(var2$,"NewSetStimFile") <> 0 then
			currsetstimfile$ := var3$;
			setstimNum% := setstimNum% +1;
		endif
		
		keepreading%:=Read(var1$,var2$,var3$,var4%,var5$);
    wend;
	PrintLog("Most Recent Behavioral Type Found:\t%s\n",behType$);
	PrintLog("Most Recent Penetration Found:\t%s\n",penetrationInfo$);
	PrintLog("Most Recent Site Found:\t\t%s\n",recordingSiteInfo$);
	PrintLog("Most Recent Epoch Found:\t%s\n",epochInfo$);
	'
	if InStr(currsetstimfile$,"nocurrsetstimfile") = 0 then
		PrintLog("Most Recent currsetstimfile$ Found:\t%s\n",currsetstimfile$);	
	endif
endif	
'
FilePathSet(stimPath$);
numfoundcurrsetstimfiles% := FileList(foundcurrsetstimfiles$[],-1,"*.currsetstim");
var i%;
for i%:= 0 to  numfoundcurrsetstimfiles%-1 do
	foundcurrsetstimfiles$[i%] := stimPath$ +  foundcurrsetstimfiles$[i%];
next
FilePathSet(currPathDSI$);
View(currViewDSI%);
return 1;
end
'----------
'
func dofindMastersetstimfile()
var currdir$,retFL%;
currdir$ := FilePath$();
FilePathSet(stimPath$);
retFL% := FileList(mastersetstimfile$,-1,"*.MASTERstim");
if retFL% = 1 then
	mastersetstimfile$ := stimPath$ + mastersetstimfile$;
endif
FilePathSet(currdir$);
return retFL%
end
'
'
'**********
func SEaskProtocolFile%()
var retSP%;
var useProtocolFile%:=0;
'
DlgCreate("Use Protocol File?",30,.1,0,4,-1,0);
DlgText("\t\t\t\tUse Protocol File?\n\n(If not, all '.wav' files in stim folder will be loaded and given default operant parameters.)",0,1);
DlgButton(1, "Yep, Use a protocol file.");
DlgButton(0, "Nope, Use '.wav' files in stim folder - give default operant parameters.");
useProtocolFile%:= DlgShow();
'
if useProtocolFile% then
	retSP% := ImplementProtocolFile%();
	if retSP% = -1517 then 'will get here if hit cancel btn
		useProtocolFile% := SEaskProtocolFile%();
	else if retSP% < 0 then
			PL("There was an error loading some stimulus info, check 'ImplementProtocolFile%()'");
			WarnDlg("Some stimulus data did not load.","Some stimulus data did not load.");
			return -1;
		endif
	endif
endif
'
return 1;
end
'
func ImplementProtocolFile%()
var dumName$,numProts%,successSPF%:=1,numPStims%:=-1,protHandle%,readret%:=1;
var iSPS%,truncNameSPS$,testSPS$,dummySPS$,retSPS$,errSPS%,protInstruct$,protocolmode$,protocolstimselectionstyle$;
if VERBOSELOG%=1 then PL("Entering ImplementProtocolFile%");endif
var currViewSPF%:=View();         'take note of the current view
var currentPathSPF$:=FilePath$(); 'take note of the current path
var tmpclass%,tmpR,tmpI%;
'
FilePathSet(stimPath$);
numProts%:=FileList(dumName$,-1,"*_prot.txt");
if numProts%=1 then
	protHandle%:=FileOpen(dumName$,1,0);
else
	protHandle%:=FileOpen("",1,0,"Pick Protocol File to Use");
endif
'
if protHandle% < 0 then
	PL(Print$("Error opening Protocol File. Error:\t%s",Error$(protHandle%)));
	return protHandle%;
else
	protFileName$:=View(protHandle%).FileName$(3)+View(protHandle%).FileName$(4);
    protFileFullName$:= View(protHandle%).FileName$(0);
	PL(Print$("Implementing Protocol File: %s",View(protHandle%).FileName$(0)));
	'
    MoveTo(0,0,1);
    readret%:=read(protInstruct$);
    if readret%<0 then
		PL("Protocol file appears empty.");
        return -1;
    endif
	'
	var readmore% := 1,currpos%;
	while readmore% > 0 do'read through all the header info
		readret% := read(protInstruct$);
		currpos% := MoveBy(1,0);
		if readret% < 0 then
			PrintLog("Got to end of protocol file\n");
			break;
		endif       
		protInstruct$ := LCase$(protInstruct$);
		if VERBOSELOG%=1 then PrintLog("protinstruct: %s\n",protInstruct$); endif
		docase
			'
		case InStr(protInstruct$,"*** END PROTOCOL FILE ***") <> 0 then
			break;
			'	
		case InStr(protInstruct$,"protocolmode") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,protocolmode$);
			protocolmode$ := LCase$(protocolmode$);
			docase
			case InStr(protocolmode$,"neuronly") <> 0 or (InStr(protocolmode$,"recordonly") <> 0) then
				protocolmode% := 0;
			case (InStr(protocolmode$,"neurbehav") <> 0) or (InStr(protocolmode$,"behavandrecord") <> 0) then
				protocolmode% := 1;
			case InStr(protocolmode$,"behavonly") <> 0 then
				protocolmode% := 2;
			else
				PrintLog("don't know what to do with a protocol mode of: %s. Setting protocolmode% to -1",protocolmode$);
				protocolmode% := -1;
			endcase
			'
		case InStr(protInstruct$,"protocoltype") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,protocoltype$);
			docase
			case InStr(protocoltype$,"mcrand") <> 0 then
				qMC% := 1;
			case InStr(protocoltype$,"mcblock") <> 0 then
				qMC% := 2;
			case InStr(protocoltype$,"setstims") <> 0 then
				qdosetstims% := 1;
				var retdfmssf%;
				retdfmssf% := dofindMastersetstimfile();
				if retdfmssf% <> 1 then
					WarnDlg("No mastersetstimfile found","No mastersetstimfile found!\nFix this!! HALTING");
					halt;
				endif
			endcase
			'
		case InStr(protInstruct$,"protocolstimselectionstyle") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,protocolstimselectionstyle$);
			protocolstimselectionstyle$ := LCase$(protocolstimselectionstyle$);
			docase
			case InStr(protocolstimselectionstyle$,"search") <> 0 then
				protocolstimselectionstyle% := 0;
			case InStr(protocolstimselectionstyle$,"block") <> 0 then
				protocolstimselectionstyle% := 1;
			case InStr(protocolstimselectionstyle$,"random") <> 0 then
				protocolstimselectionstyle% := 2;
			else
				PrintLog("don't know what to do with a protocolstimselectionstyle of: %s. Setting protocolstimselectionstyle% to -1\n",protocolstimselectionstyle$);
				protocolstimselectionstyle% := -1;
			endcase
			'
		case InStr(protInstruct$,"peckstopon") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,peckStopOn%);
			'
		case InStr(protInstruct$,"correctiontrialson") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,correctionTrialsOn%);
			'
		case InStr(protInstruct$,"dofeedcorrectiontrials") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,doFeedCorrectionTrials%);
			'
		case InStr(protInstruct$,"trialsavailablecycleonminutes") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,trialAvailablityMins%[1]);
			'
		case InStr(protInstruct$,"trialsavailablecycleoffminutes") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,trialAvailablityMins%[0]); 
			'
		case InStr(protInstruct$,"despctpres") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,tmpclass%,tmpR);
			desPctPres[tmpclass%] := tmpR;
			'
		case InStr(protInstruct$,"despctreinf") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,tmpclass%,tmpI%);
			desPctReinf%[tmpclass%] := tmpI%;
			'
		case InStr(protInstruct$,"despctto") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,tmpclass%,tmpI%);
			desPctTo%[tmpclass%] := tmpI%;
			'
		case InStr(protInstruct$,"respwin") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,RESPWIN);
			'	
		case InStr(protInstruct$,"feed") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,FEED);
			'
		case InStr(protInstruct$,"timeout") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,TIMEOUT);
			'
		case InStr(protInstruct$,"iti") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,ITI);
			'
		case InStr(protInstruct$,"itino") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,ITINO);
			'
		case InStr(protInstruct$,"maxitino") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MAXITINO);
			'
		case InStr(protInstruct$,"minitino") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MINITINO);
			'
		case InStr(protInstruct$,"stimfilename") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,stimFileFullName$);
			'			
		case InStr(protInstruct$,"currsetstimparamsfile") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,currsetstimparamsfile$);
			'
		case InStr(protInstruct$,"usepreviousset") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,qusepreviousset%);
			'
		case InStr(protInstruct$,"sscriterioncorrect") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,tmpclass%,tmpI%);
			ssCriterionCorrect%[tmpclass%] := tmpI%;
			'
		case InStr(protInstruct$,"sscriterionlength") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,ssCriterionLength%);
			resize lastN%[numsetstimclasses%+1][ssCriterionLength%];
			'
		case InStr(protInstruct$,"mcmaxnummots") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCmaxnummots%);
			'
		case InStr(protInstruct$,"mcminnummots") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCminnummots%);
			'
		case InStr(protInstruct$,"mcclassonemaxnummots") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclassoneMaxnummots%);
			'
		case InStr(protInstruct$,"mcclassonepctreinf") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclassonePctReinf%);
			'
		case InStr(protInstruct$,"mcclassonepctto") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclassonePctTo%);
			'
		case InStr(protInstruct$,"mcclasstwomaxnummots") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclasstwoMaxnummots%);
			'
		case InStr(protInstruct$,"mcclasstwopctreinf") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclasstwoPctReinf%);
			'
		case InStr(protInstruct$,"mcclasstwopctto") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclasstwoPctTo%);
			'
		case InStr(protInstruct$,"mcclassthreemaxnummots") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclassthreeMaxnummots%);
			'
		case InStr(protInstruct$,"mcclassthreepctreinf") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclassthreePctReinf%);
			'
		case InStr(protInstruct$,"mcclassthreepctto") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCclassthreePctTo%);
			'
		case InStr(protInstruct$,"mcallowlr") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCallowLR%);
			'
		case InStr(protInstruct$,"mcallowambig") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,MCallowambig%);
			'
		case InStr(protInstruct$,"beginhours") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,beginHours%);
			beginningOfDayInMinutesSinceMidnight% := beginHours%*60 + beginMins%;
			'
		case InStr(protInstruct$,"beginmins") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,beginMins%);
			beginningOfDayInMinutesSinceMidnight% := beginHours%*60 + beginMins%;
			'
		case InStr(protInstruct$,"endhours") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,endHours%);
			if dontuseTODStartStop% = 1 then
				endOfDayInMinutesSinceMidnight% := 9999; 'The day will never end!!!
			else
				endOfDayInMinutesSinceMidnight% := endHours%*60 + endMins%;
			endif
			'
		case InStr(protInstruct$,"endmins") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,endMins%);
			if dontuseTODStartStop% = 1 then
				endOfDayInMinutesSinceMidnight% := 9999; 'The day will never end!!!
			else
				endOfDayInMinutesSinceMidnight% := endHours%*60 + endMins%;
			endif
			'
		case InStr(protInstruct$,"dontusetodstartstop") <> 0 then
			MoveBy(0,0,-1);
			readret% := read(protInstruct$,dontuseTODStartStop%);
			if dontuseTODStartStop% = 1 then
				endOfDayInMinutesSinceMidnight% := 9999; 'The day will never end!!!
			else
				endOfDayInMinutesSinceMidnight% := endHours%*60 + endMins%;
			endif 
			'
		else
			PrintLog("Have protocol file header variable that I don't know what to do with:\t%s\n",protInstruct$);
		endcase
		if readret% < 0 then
			PrintLog("Got through part (but not all) of the protocol file header info. Error:\t%s\n",Error$(readret%));
		endif                
	wend
endif	
'
View(currViewSPF%);
FilePathSet(currentPathSPF$);
View(protHandle%).FileClose(0);
qProtocolFileSetup%:=1;
return successSPF%
end
'
'----------
'
'**********
func SEpickMode%(inMode%)
'PickMode will either take an input passed in (presumably read from a protocol file), or give the user a selection dialog.
var retPM%;
'
if inMode% < 0 then
    DlgCreate("Pick Mode",30,.1,0,3,-1,0);
    DlgText("Select what type of script control you want.",0,0);
    DlgButton(0, "Record Neural Activity Only", SetRecordOnly%,63,1);
    DlgButton(1, "Record Behavioral and Neural Data", SetBehavAndRecord%,30,1);
    DlgButton(2, "Record Behavioral Data Only", SetBehavOnly%,1,1);
    DlgButton(3, "Cancel Epoch Setup",0,1,2.5);
    retPM%:=DlgShow();
else
    docase
    case inMode% = 0 then
        SetRecordOnly%();
    case inMode% = 1 then
        SetBehavAndRecord%();
    case inMode% = 2 then
        SetBehavOnly%();        
    else
    endcase
    retPM% := inMode%;
endif
'
return retPM%;
end
'
func SetRecordOnly%()
qhRecordingAndBehavior%:=0;
qhRecordingOnly%:=1;
qhBehavOnly%:=0;
PL("'Neural Recording Only' mode set");
return 0;
end
'
func SetBehavAndRecord%()
qhRecordingAndBehavior%:=1;
qhRecordingOnly%:=0;
qhBehavOnly%:=0;
PL("'Behavior Plus Neural Activity' mode set");
return 0;
end
'
func SetBehavOnly%()
qhRecordingAndBehavior%:=0;
qhRecordingOnly%:=0;
qhBehavOnly%:=1;
PL("'Behavior Only' mode set");
return 0;
end
'----------
'
'**********
func SEsetRecordingLocationInfo%(&subjectInfoHandle%)
if qhRecordingAndBehavior% or qhRecordingOnly% then
	if penetrationNum% = 0 then
		DoPenetration%(1,subjectInfoHandle%);
	else
		DoPenetration%(0,subjectInfoHandle%);
	endif
else 'if qhBehavOnly% use all most recent info
	if penetrationNum% = 0 then
		dataPathRecordingSite$ := dataPathRoot$+"prePenetrationBehaviorOnly\\";
	else
		dataPathPenetration$:=dataPathRoot$+penetrationInfo$+"\\";
		dataPathRecordingSite$:=dataPathPenetration$+recordingSiteInfo$+"\\";
		FilePathSet(dataPathRecordingSite$,0,1);	
		PrintLog("File Path Set to:\t\t%s\n",dataPathRecordingSite$);
	endif
endif
return 1;
end
'
func DoPenetration%(newPen%,&subjectInfoHandle%)
var pHem%,pAP%,pML%,pencomments$,currPHem$;
var currpAP%,currpML%,retDP%;

if newPen% then
	'
	DlgCreate("New penetration",30,.1,0,8,-1,0);
	DlgList(1,"Hemisphere (from bird perspective)","Left|Right");
	DlgInteger(2,"Anterior/Posterior (Anterior Positive) (um)",0,5000,0,0,1);
	DlgInteger(3,"Medial/Lateral (Left Positive)(um)",0,2000,0,0,1);
	DlgString(4,"Comments: ",200);
	'DlgButton(3, "Cancel Epoch Setup",0,1,8);
	'
	retDP% := DlgShow(pHem%,pAP%,pML%,pencomments$);
	
	'if retDP% = 3 then
	'		PL("User Cancelled Epoch Setup");
	'ToolbarEnable(STARTEPOCHID%,1);
	'	return 1;
	'	endif
	
	if retDP% = 1 then
		penetrationNum%:=penetrationNum%+1;
		recordingSiteNum%:=0;
		if pHem% then
			currPHem$:="Rgt";
		else
			currPHem$:="Lft";
		endif;
		currpAP%:=pAP%;
		currpML%:=pML%;
		penetrationInfo$:=Print$("Pen%02d_%s_AP%d_ML%d",penetrationNum%,currPHem$,currpAP%,currpML%);
		
		'Write to subject info file	
		View(subjectInfoHandle%).Print("\n\n\n----------------------------------------------------------------\n");
		View(subjectInfoHandle%).Print("----------------------------------------------------------------\n");
		View(subjectInfoHandle%).Print("\n\"%s\",\"Penetration\",\"%s\",%d,\"%s\"\n",GetTimeStamp$(),penetrationInfo$,penetrationNum%,pencomments$);
		View(subjectInfoHandle%).FileSave();
		
		dataPathPenetration$:=dataPathRoot$+penetrationInfo$+"\\";
		if FilePathSet(dataPathPenetration$,0,1) <0 then
			WarnDlg("Cannot set Penetration path","Cannot set Penetration path, likely saving to subject data path.");	
			FilePathSet(dataPathRoot$,0,1);
			PL(Print$("File Path Set to: %s",dataPathRoot$));
		else
			PL(Print$("File Path Set to: %s",dataPathPenetration$));	
			PL(Print$("New Penetration: %s",penetrationInfo$));
		endif
		'
		DoElectrode%(-1,subjectInfoHandle%);
		DoSite%(1,subjectInfoHandle%);
	else
		if penetrationInfo$ <> "" then
			DoPenetration%(0,subjectInfoHandle%);
		else
			DoPenetration%(1,subjectInfoHandle%);
		endif
		return 1;
	endif
	return 1;
else
	DlgCreate("Use Current Penetration?",30,.1,0,5,-1,0);
	DlgText(Print$("Use current Penetration?\n\n%s",penetrationInfo$),0,2);
	DlgButton(0,"No, Create New Penetration");
	DlgButton(1,"Yes, Use Current Penetration");
	if not DlgShow() then
		DoPenetration%(1,subjectInfoHandle%); 
		return 1;
	endif
	PL(Print$("Using Current Penetration: %s\tfrom Subject Info File: %s",penetrationInfo$,subjectInfoName$));
	dataPathPenetration$:=dataPathRoot$+penetrationInfo$+"\\";
	FilePathSet(dataPathPenetration$,0,1);	
	PL(Print$("File Path Set to: %s",dataPathPenetration$));
	DoElectrode%(infoFileTrodeType%,subjectInfoHandle%); 'this will set current site mapping
	DoSite%(0,subjectInfoHandle%); 'Ask if user wants to use an already set-up recording site
	return 1;
endif;
end;
'
func DoElectrode%(desiredTrodeType%,&subjectInfoHandle%) 'pass anything negative to get a trode selection dialogue
'
if desiredTrodeType% < 0 then
	DlgCreate("Set electrode type",30,.1,0,7,-1,0);
	'var eMfg$,ePartNo$,eLotNo$,eMfgDate$,eDiam,eLen,eImp%,eDesc$;
	'DlgString(1,"Manufacturer",20," a-zA-Z0-9",0,0,"AM Systems|Custom");
	'DlgString(2,"Part number",10," a-zA-Z0-9",0,0,"573200");
	'DlgString(3,"Lot number",10," a-zA-Z0-9",0,0,"536650");
	'DlgString(4,"Date of mfg",8,"0-9-",0,0,"01-05-05");
	'DlgReal(5,"Diameter (inches)",0.001,0.010,0,0,0.001);
	'DlgReal(6,"Length (inches)",1.0,5.0,0,0,0.1);
	'DlgInteger(7,"Impedence (MOhm)",1,100,0,0,1);
	'DlgString(8,"Description",50," a-zA-Z0-9",0,0,"Tungsten Parylene|Custom Parameters");
	DlgList(1,60,eTrodeList$[]);
	DlgButton(0,"");
	DlgString(2,"Impedance/Site Area:",100);
	DlgString(3,"ProbeID# (negative if none):",100);
	DlgString(4,"Additional electrode comments:",200);
	
	DlgShow(trodeType%,eTrodeImpedance$,eTrodeID$,eTrodeComments$);
	
	electrodeInfo$:=Print$("trodeType_%d_Impedance_%s_ID_%s",trodeType%,eTrodeImpedance$,eTrodeID$);
	
	'Write to subject info file	
	View(subjectInfoHandle%).Print("\n\"%s\",\"Electrode\",\"%s\",%d,\"%s\"\n",GetTimeStamp$(),electrodeInfo$,trodeType%,eTrodeComments$);
	View(subjectInfoHandle%).FileSave();
else
	if 0 <= desiredTrodeType% <= 3 then
		trodeType%:=desiredTrodeType%;
	else
		PL("what kind of trode are you using?");
	endif
endif
'
docase
case trodeType% = 0 then '2x2 tetrode (F16)
	nWavChans%:=17; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1] 	:=3;
	currChanMap%[2] 	:=5;
	currChanMap%[3] 	:=11;
	currChanMap%[4] 	:=9;
	currChanMap%[5] 	:=14;
	currChanMap%[6] 	:=12;
	currChanMap%[7] 	:=6;
	currChanMap%[8] 	:=8;
	currChanMap%[9] 	:=2;
	currChanMap%[10]	:=4;
	currChanMap%[11]	:=10;
	currChanMap%[12]	:=1;
	currChanMap%[13]	:=15;
	currChanMap%[14]	:=13;
	currChanMap%[15]	:=7;
	currChanMap%[16]	:=16;
	currChanMap%[17]	:=32;'stiminput
	
	
case trodeType% = 1 then '1x16 neuronexus  (F16)
	nWavChans%:=17; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=11;
	currChanMap%[2]:=12;
	currChanMap%[3]:=10;
	currChanMap%[4]:=13;
	currChanMap%[5]:=9;
	currChanMap%[6]:=14;
	currChanMap%[7]:=1;
	currChanMap%[8]:=15;
	currChanMap%[9]:=2;
	currChanMap%[10]:=16;
	currChanMap%[11]:=3;
	currChanMap%[12]:=8;
	currChanMap%[13]:=4;
	currChanMap%[14]:=7;
	currChanMap%[15]:=5;
	currChanMap%[16]:=6;
	currChanMap%[17]:=32; 'stiminput
	
case trodeType% = 2 then '1x32 neuronexus
	nWavChans%:=32;
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	
	'values below are likely incorrect - do not take into account the probe connector	
	
	'	currChanMap%[1]:=1;
	'	currChanMap%[2]:=2;
	'	currChanMap%[3]:=3;
	'	currChanMap%[4]:=4;
	'	currChanMap%[5]:=5;
	'	currChanMap%[6]:=6;
	'	currChanMap%[7]:=7;
	'	currChanMap%[8]:=8;
	'	currChanMap%[9]:=9;
	'	currChanMap%[10]:=10;
	'	currChanMap%[11]:=11;
	'	currChanMap%[12]:=12;
	'	currChanMap%[13]:=13;
	'	currChanMap%[14]:=14;
	'	currChanMap%[15]:=15;
	'	currChanMap%[16]:=16;
	'	currChanMap%[17]:=17;
	'	currChanMap%[18]:=18;
	'	currChanMap%[19]:=19;
	'	currChanMap%[20]:=20;
	'	currChanMap%[21]:=21;
	'	currChanMap%[22]:=22;
	'	currChanMap%[23]:=23;
	'	currChanMap%[24]:=24;
	'	currChanMap%[25]:=25;
	'	currChanMap%[26]:=26;
	'	currChanMap%[27]:=27;
	'	currChanMap%[28]:=28;
	'	currChanMap%[29]:=29;
	'	currChanMap%[30]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	'	currChanMap%[31]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	'	currChanMap%[32]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	'	currChanMap%[33]:=30;
	'	currChanMap%[34]:=31;
	'	currChanMap%[35]:=32;
	
	sampleRate% := 17000;	'needs to be lower for so many more channels
	
case trodeType% = 3 then 'single platinum iridium
	nWavChans%:=2; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=1;
	currChanMap%[2]:=2; 'stim channel
	
case trodeType% = 4 then '1 to 1 (16)
	nWavChans%:=17; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=1;
	currChanMap%[2]:=2;
	currChanMap%[3]:=3;
	currChanMap%[4]:=4;
	currChanMap%[5]:=5;
	currChanMap%[6]:=6;
	currChanMap%[7]:=7;
	currChanMap%[8]:=8;
	currChanMap%[9]:=9;
	currChanMap%[10]:=10;
	currChanMap%[11]:=11;
	currChanMap%[12]:=12;
	currChanMap%[13]:=13;
	currChanMap%[14]:=14;
	currChanMap%[15]:=15;
	currChanMap%[16]:=16;
	currChanMap%[17]:=32; 'stiminput
	
case trodeType% = 5 then '1 to 1 (32)
	nWavChans%:=36;
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=1;
	currChanMap%[2]:=2;
	currChanMap%[3]:=3;
	currChanMap%[4]:=4;
	currChanMap%[5]:=5;
	currChanMap%[6]:=6;
	currChanMap%[7]:=7;
	currChanMap%[8]:=8;
	currChanMap%[9]:=9;
	currChanMap%[10]:=10;
	currChanMap%[11]:=11;
	currChanMap%[12]:=12;
	currChanMap%[13]:=13;
	currChanMap%[14]:=14;
	currChanMap%[15]:=15;
	currChanMap%[16]:=16;
	currChanMap%[17]:=17;
	currChanMap%[18]:=18;
	currChanMap%[19]:=19;
	currChanMap%[20]:=20;
	currChanMap%[21]:=21;
	currChanMap%[22]:=22;
	currChanMap%[23]:=23;
	currChanMap%[24]:=24;
	currChanMap%[25]:=25;
	currChanMap%[26]:=26;
	currChanMap%[27]:=27;
	currChanMap%[28]:=28;
	currChanMap%[29]:=29;
	currChanMap%[30]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[31]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[32]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[33]:=30;
	currChanMap%[34]:=31;
	currChanMap%[35]:=32;
    currChanMap%[36]:=33; 'stiminput
	
	'sampleRate% := 17000;	'might need to be lower for so many more channels	
	
    
case trodeType% = 6 then '1x16 neuronexus + 8 LFP (using plexon's every-other-channel adapter)
	nWavChans%:=23; 'extra for stim recording + 6 LFP
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=11;
	currChanMap%[2]:=12;
	currChanMap%[3]:=10;
	currChanMap%[4]:=13;
	currChanMap%[5]:=9;
	currChanMap%[6]:=14;
	currChanMap%[7]:=1;
	currChanMap%[8]:=15;
    
	currChanMap%[9]:=2;
	currChanMap%[10]:=16;
	currChanMap%[11]:=3;
	currChanMap%[12]:=8;
	currChanMap%[13]:=4;
	currChanMap%[14]:=7;
	currChanMap%[15]:=5;
	currChanMap%[16]:=6;
	
    
    currChanMap%[17]:=25;
    currChanMap%[18]:=26;
	currChanMap%[19]:=27;
	currChanMap%[20]:=29;
	currChanMap%[21]:=30;
	currChanMap%[22]:=31;
    
	currChanMap%[23]:=32; 'stiminput
	
case trodeType% = 7 then '1x16 neuronexus  (H16 connector)
	nWavChans%:=17; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=4;
	currChanMap%[2]:=5;
	currChanMap%[3]:=2;
	currChanMap%[4]:=7;
	currChanMap%[5]:=1;
	currChanMap%[6]:=8;
	currChanMap%[7]:=12;
	currChanMap%[8]:=13;
	currChanMap%[9]:=9;
	currChanMap%[10]:=16;
	currChanMap%[11]:=10;
	currChanMap%[12]:=15;
	currChanMap%[13]:=11;
	currChanMap%[14]:=14;
	currChanMap%[15]:=3;
	currChanMap%[16]:=6;
	currChanMap%[17]:=32; 'stiminput
    
case trodeType% = 8 then '1x32 neuronexus  (A32 connector) BURUNG
	nWavChans%:=32+3+1; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=21;
	currChanMap%[2]:=33;
	currChanMap%[3]:=24;
	currChanMap%[4]:=35;
	currChanMap%[5]:=22;
	currChanMap%[6]:=34;
	currChanMap%[7]:=23;
	currChanMap%[8]:=38;
	currChanMap%[9]:=20;
	currChanMap%[10]:=36;
	currChanMap%[11]:=26;
	currChanMap%[12]:=40;
	currChanMap%[13]:=19;
	currChanMap%[14]:=37;
	currChanMap%[15]:=28;
	currChanMap%[16]:=42;
	currChanMap%[17]:=18;
	currChanMap%[18]:=39;
	currChanMap%[19]:=30;
	currChanMap%[20]:=46;
	currChanMap%[21]:=17;
	currChanMap%[22]:=44;
	currChanMap%[23]:=32;
	currChanMap%[24]:=48;
	currChanMap%[25]:=25;
	currChanMap%[26]:=41;
	currChanMap%[27]:=27;
	currChanMap%[28]:=43;
	currChanMap%[29]:=29;
	currChanMap%[30]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[31]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[32]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[33]:=45;
	currChanMap%[34]:=31;
	currChanMap%[35]:=47;
	currChanMap%[36]:=8; 'stiminput
    
    'sampleRate% := 17000;	'might need to be lower for so many more channels - NOT SURE BURUNGHACK case trodeType% = 8 then '4x8 N-Form Modular Bionics X018 (A32 connector) BURUNG

case trodeType% = 9 then '4x8 N-Form, Modular Bionics (A32 connector) BURUNG	
    nWavChans%:=36; 'extra for stim recording
	currChanMap%[0]:=nWavChans%; 'Relevant size of currChanMap%
	
	currChanMap%[1]:=17;
	currChanMap%[2]:=18;
	currChanMap%[3]:=19;
	currChanMap%[4]:=20;
	currChanMap%[5]:=21;
	currChanMap%[6]:=22;
	currChanMap%[7]:=23;
	currChanMap%[8]:=24;
	currChanMap%[9]:=25;
	currChanMap%[10]:=26;
	currChanMap%[11]:=27;
	currChanMap%[12]:=28;
	currChanMap%[13]:=29;
	currChanMap%[14]:=30;
	currChanMap%[15]:=31;
	currChanMap%[16]:=32;
	currChanMap%[17]:=33;
	currChanMap%[18]:=34;
	currChanMap%[19]:=35;
	currChanMap%[20]:=36;
	currChanMap%[21]:=37;
	currChanMap%[22]:=38;
	currChanMap%[23]:=39;
	currChanMap%[24]:=40;
	currChanMap%[25]:=41;
	currChanMap%[26]:=42;
	currChanMap%[27]:=43;
	currChanMap%[28]:=44;
	currChanMap%[29]:=45;
	currChanMap%[30]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[31]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[32]:=-1;'should be skipped due to crazy indexing in savedWFChans% due to chans 30, 31, 32 being reserved
	currChanMap%[33]:=46;
	currChanMap%[34]:=47;
	currChanMap%[35]:=48;
	currChanMap%[36]:=8; 'stiminput   
    
else
	PL("What trode type are you using?");
endcase
'
return trodeType%
end;
'
func DoSite%(newsite%,&subjectInfoHandle%)
var sDepth%,siteComments$,currRSDepth%;

if newsite% = 1 or newsite% = 2 then
	DlgCreate("New recording site",30,.1,0,5,-1,0);
	DlgText(Print$("(old site = %s)",recordingSiteInfo$),0,0);
	DlgInteger(1,"New Depth (um of tip of probe)",0,5000,0,0,1);
	DlgString(2,"Comments: ",200);
	'
	if DlgShow(sDepth%,siteComments$) then
		'blockNum%:=0;
		epochNum% := 0;
		recordingSiteNum%:=recordingSiteNum%+1;
		currRSDepth%:=sDepth%;
		recordingSiteInfo$:=Print$("Site%02d_Z%d",recordingSiteNum%,currRSDepth%);
		
		'Write to subject info file	
		View(subjectInfoHandle%).Print("\n\n\n--------------------------\n");
		View(subjectInfoHandle%).Print("\n\n\"%s\",\"Site\",\"%s\",%d,\"%s\"\n",GetTimeStamp$(),recordingSiteInfo$,recordingSiteNum%,siteComments$);
		View(subjectInfoHandle%).FileSave();
		dataPathRecordingSite$:=dataPathPenetration$+recordingSiteInfo$+"\\";
		if FilePathSet(dataPathRecordingSite$,0,1) <0 then
			WarnDlg("Cannot set recording site path","Cannot set recording site path, likely saving to penetration path.");	
			FilePathSet(dataPathPenetration$,0,1);
			PL(Print$("File Path Set to: %s",dataPathPenetration$));
		else
			PL(Print$("File Path Set to: %s",dataPathRecordingSite$));	
			PL(Print$("New Recording Site: %s",recordingSiteInfo$));
		endif
	else
		if newsite% = 2 then
			DoSite%(0,subjectInfoHandle%);
		else
			DoSite%(1,subjectInfoHandle%);
		endif
		return 1;
	endif
	return 1;
else
	DlgCreate("Use Current Recording Site?",30,.1,0,5,-1,0);
	DlgText(Print$("Use Current Recording Site?\n\n%s",recordingSiteInfo$),0,2);
	DlgButton(0,"No, Create New Recording Site");
	DlgButton(1,"Yes, Use Current Recording Site");
	if not DlgShow() then
		DoSite%(2,subjectInfoHandle%);
	endif
	PL(Print$("Using Current Recording Site: %s\tfrom Subject Info File: %s",recordingSiteInfo$,subjectInfoName$));
	dataPathRecordingSite$:=dataPathPenetration$+recordingSiteInfo$+"\\";
	FilePathSet(dataPathRecordingSite$,0,1);	
	PL(Print$("File Path Set to: %s",dataPathRecordingSite$));
	return 1;
endif;
end;
'----------
'
'**********
func SEdoSamplingConfig%()
'
docase
case qhRecordingAndBehavior% then
	seqfile$ := chronNBseq$; 'chronic rig, behavior and neural recording
	SetSaveChans%();
case qhRecordingOnly% then
	seqfile$ := chronNOseq$; 'chronic rig, neural recording only
	SetSaveChans%();
case qhBehavOnly% then
	seqfile$ := chronNBseq$; 'chronic rig, behavior and neural recording
	nWavChans%:=1;
else
	PL("Impossible! neither qhRecordingAndBehavior% nor qhRecordingOnly% nor qhBehavOnly% = 1. HALTING\n");
	halt;
endcase
'
var retSW%[nWavChans%],retSS%,retSDM%,retSTM%,retELE%:=0,iDC%,successDC%:=0,retPWA%,retPWD%,retPWR%,asname$,stDM%,stKB%;
ArrConst(retSW%,0);
'
SampleClear();
SampleChannels(MAXCHANSPERFILE%);

'
stKB% := SampleTrigger(2,31,-1,relS,relE,-1);  'set up keyboard trigger
'
'set up autosave - will flush data to disk every 5 minutes
SampleAutoFile(1); 'turn on autosave
'FilePathSet(dataPathRoot$,3);
asname$:=SampleAutoName$("AutoSv-%m%d%y_%H-%M-%S");
SampleAutoCommit(300); 'flush to disk every 300 seconds (5 minutes)
'
PL("\n\nSetting Up Sampling Configuration\n");
retSS% := SampleSequencer(seqfile$);    'set sequencer file
if (retSS%=0) then
    PrintLog("Sequencer file sucessfully set to:\t%s\n", SampleSequencer$());
    SampleSeqCtrl(1,0);                 'Set sequencer option
    retSDM%:=SampleDigMark(100);        'add digimark channel
    if retSDM%=0 then
		if qhRecordingOnly% then
			stDM% := SampleTrigger(1,32,-1,relS,relENO,-1);  'setup trigger for digmark channel
		else
			stDM% := SampleTrigger(1,32,-1,relS,relE,-1);  'setup trigger for digmark channel
		endif
        retSTM%:=SampleTextMark(100);   'add textmark channel
        if retSTM%=0 then
			if qhBehavOnly% then     'BURUNGHACK will totally break on burung
				
				retSW%[0]:= SampleWaveform(BOmicchannel%,BOmicport%,BehavOnlysampleRate%); 'add waveform channel for microphone input
				if retSW%[0] <> 0 then; PrintLog("ERROR:\t%s\n",Error$(retSW%[0]));endif;
				SampleOptimise(2,1,type1401%,BOsampoptuslow%,BOsampoptushigh%); 'need to change this depending on which 1401 we use '4 for manu '5 for chronic rig '7 for burung 'BURUNGHACK
				PrintLog("Chan %d: Expected waveform rate: %f | Actual waveform rate: %f\n",17,SampleChanInfo(16,2),SampleChanInfo(16,4));
				if SampleChanInfo(16,2) < 0 then PrintLog("SampleChanInfo returned ERROR: %s\n",Error$(SampleChanInfo(16,2)));endif
				PrintLog("All channels successfully added to configuration.\n");
				
				successDC%:=1;
			else
				for iDC%:=1 to savedWFChans%[0] do 
					retSW%[iDC%-1]:=SampleWaveform(savedWFChans%[iDC%],currChanMap%[savedWFChans%[iDC%]]-1,sampleRate%);  'add waveform channel for each 'trode
					if retSW%[iDC%-1] <> 0 then
						PrintLog("ERROR:\t%s\n",Error$(retSW%[iDC%-1]));
					endif
                next;
				if ArrSum(retSW%)=0 then 
					'SampleOptimise(2,1,type1401%,1,100); 'need to change this depending on which 1401 we use '4 for manu '5 for chronic rig '7 for burung 'BURUNGHACK
					SampleOptimise(2,1,type1401%,NONBsampoptuslow%,NONBsampoptushigh%,-1,1); 'need to change this depending on which 1401 we use '4 for manu '5 for chronic rig '7 for burung 'BURUNGHACK
					if VERBOSELOG%=1 then PrintLog("All channels successfully added to configuration.\n"); endif
					successDC%:=1;
					for iDC%:=1 to savedWFChans%[0] do 
						PrintLog("Chan %d: Expected waveform rate: %f | Actual waveform rate: %f\n",savedWFChans%[iDC%],SampleChanInfo(savedWFChans%[iDC%],2),SampleChanInfo(savedWFChans%[iDC%],4));
                    next;
				else
					PrintLog("ERROR: Failed to open waveform channel for sampling, check 'retSW%'\n");
				endif;
			endif
        else
            PrintLog("ERROR: Failed to open textmark channel.  error is: %s\n",Error$(retSTM%));
        endif;
    else
        PrintLog("ERROR: Failed to open digimark channel.  error is: %s\n",Error$(retSDM%));
    endif;
else
    PrintLog("ERROR: Failed to attach the sequencer file '%s', error is: %s\n",seqfile$, Error$(retSS%));
endif
'
'check the triggers
if VERBOSELOG% then PrintLog("SampleTrigger DM returned %d\n",stDM%);PrintLog("SampleTrigger KB returned %d\n",stKB%);endif
if stDM% <> 0 or stKB% <> 0 then
	PrintLog("SampleTrigger DM returned %d, Error: %s. HALTING.\n",stDM%,Error$(stDM%));
	PrintLog("SampleTrigger KB returned %d, Error: %s. HALTING.\n",stKB%,Error$(stKB%));
	halt;
endif
'
'Now print the sampling config to the logfile
PrintLog("SampleOptimise - Method:\t%d\n",SampleOptimise(0));
PrintLog("SampleOptimise - Group:\t\t%d\n",SampleOptimise(1));
PrintLog("SampleOptimise - Type:\t\t%d\n",SampleOptimise(2));
PrintLog("SampleOptimise - usLo:\t\t%d\n",SampleOptimise(3));
PrintLog("SampleOptimise - usHi:\t\t%d\n",SampleOptimise(4));
PrintLog("SampleOptimise - Disable:\t%d\n",SampleOptimise(5));
PrintLog("SampleOptimise - Burst:\t\t%d\n",SampleOptimise(6));
usecpertime := SampleUsPerTime();
PrintLog("SampleUsPerTime:\t\t%f\n",usecpertime);
timeperADC := SampleTimePerAdc();
PrintLog("SampleTimePerAdc:\t\t%f\n",timeperADC);
'
'set up audio
retPWD%:=PlayWaveDelete();
if retPWD%<>0 then; 'delete all playwave areas.  start with a blank slate!
	PL("ERROR: Unable to delete play wave areas.");
endif;
retPWA% := PlayWaveAdd(audioPWAKey$, "&AudOut", 0, REQUESTEDaudioOutRate%, audBuffSize%);
if retPWA% < 0 then
	PL(Print$("ERROR: Error adding playwave area. error is: ",Error$(retPWA%)));
	successDC% := 0;
else
	retPWR%  := PlayWaveRate(audioPWAKey$);
	PrintLog("Playwave area successfully added to configuration. Buffer is %d bytes on 1401.\n REQUESTEDaudioOutRate% is: %d\n",retPWA%,retPWR%);
endif;
'
'
return successDC%;
end;
'
func SetSaveChans%() 
'TODO: add code to allow inputs to SetSaveChans% to select the chans - use for behav only and for protocol file selection of channels to use
'TODO: add code to be able to pick groups of channels quickly, ie whole tetrodes at a time; put check boxes in same order as chan order...?
var ssc%,ssc1%,ssc2%,ssc3%,chooseWFChans%[nWavChans%+2];
savedWFChans%[0]:=0;
if trodeType% <> 3 then
	DlgCreate("Which Channels to Record?",32.5,0.1,50,nWavChans%+2,-1,0);
	DlgButton(1,"Save Checked Channels",0,20,(nWavChans%/2));
	DlgButton(0,"Save All Channels",0,22.5,(nWavChans%/2)+3);
else
	DlgCreate("Which Channels to Record?",32.5,0.1,50,nWavChans%+2,-1,0);
	DlgButton(1,"Save Checked Channel",0,20,(nWavChans%/2)+1);
	DlgButton(0,"Save All Channels",0,22.5,(nWavChans%/2)+2);
endif

for ssc% :=1 to currChanMap%[0] do
	DlgCheck(ssc%,Print$("%d",ssc%),10,1+ssc%);
next;

DlgButton(2,"Select all",SelectAllSSC%,25.5,(nWavChans%/2)-3);
DlgButton(3,"Clear all",ClearAllSSC%,26,(nWavChans%/2)-1.5);
var retret%;
retret%:=DlgShow(chooseWFChans%[]);
if  retret%=0 then
	PL("Saving all channels.");
	savedWFChans%[0]:=nWavChans%; 'use convention of zeroth index being num elements
	for ssc1%:=1 to nWavChans% do	
		savedWFChans%[ssc1%]:=ssc1%;
    next
else
	PrintLog("User selected the following channels to save");
	for ssc2%:=1 to nWavChans% do
		if chooseWFChans%[ssc2%-1] = 1 then	
			savedWFChans%[0]+=1;
			savedWFChans%[savedWFChans%[0]]:=ssc2%;
			PrintLog(", %d",ssc2%);
		endif
    next
	PrintLog("\n");
endif

for ssc3%:=1 to savedWFChans%[0] do 'have to do this because chans 30-32 are hardcoded for keyboard, textmark, and digmark
	if savedWFChans%[ssc3%] > 29 then
		docase
		case savedWFChans%[ssc3%] = 30 then
			savedWFChans%[ssc3%] := 33;
		case savedWFChans%[ssc3%] = 31 then
			savedWFChans%[ssc3%] := 34;
		case savedWFChans%[ssc3%] = 32 then
			savedWFChans%[ssc3%] := 35;
		endcase;
	endif;
next;

return 1;
end
'
func SelectAllSSC%()
var iSA%;
for iSA% :=1 to currChanMap%[0] do
	DlgValue(iSA%,1);
next;
return 1;
end;
'
func ClearAllSSC%()
var iCA%;
for iCA% :=1 to currChanMap%[0] do
	DlgValue(iCA%,0);
next;
return 1;
end;
'----------
'
'**********
func SEsetupStims%()
var iSS%,totrndplist%:=0,nnStim%;
var retLSF%;
totpres%:=0;
'    

if InStr(stimFileFullName$,"AskMe") <> 0 then
	if AskStimFile%() <> 1 then
		return 0;
	endif
endif

'
if qdosetstims% = 1 then
	if qneednewset% = 1 then
		qusepreviousset% := 0;
	endif
	currsetstimfile$ := SSSetupStimulusSet$(mastersetstimfile$,qusepreviousset%);
	stimFileFullName$ := currsetstimfile$;
	if InStr(currsetstimfile$,"nocurrsetstimfile") = 0 then
		PL("New Set setup successful.");
	else
		PL("New Set setup failed.");
		return 0;
	endif	
endif
'
if InStr(stimFileFullName$,"NoStimFileDesired") <> 0 then 'use default setup: look for wav files in stims folder, set up with default values, even stims are class 1, odd are class 2
	if LoadStimFolderStims%() <> 1 then    'grabs all .wav files in subject's stim folder
		PL("Problem in LoadStimFolderStims%.");
		return 0;
	endif
else
	if LoadStimFileStims%(stimFileFullName$) <> 1 then 'load stims from stim file given in protocol file or selected by user
		PL("Problem in LoadStimFileStims%.");
		return 0;
	endif
endif
'
if UpdateStimParams%() <> 1 then     'updates stimulus parameters with those indicated in the protocol file
	PL("Problem in UpdateStimParams%.");
	return 0;
endif
'
if FinalizeStims%() <> 1 then 	'Creates rand plist and initializes block and search plists, prints stim parameters to log file
	PL("Problem in FinalizeStims%.");
	return 0;
endif
'
return 1 'TODO: do some error checking
end
'
func LoadStimFolderStims%()
'
var iSS%,nnStim%;
'
ConvertStimFiles();
FilePathSet(stimPath$);
numStimFiles% := FileList(stimFileNames$[],0,"*"+datafileextension$);
'
for iSS% := 0 to numStimFiles%-1 do
	if iSS% mod 2 = 1 then
		stimClasses%[iSS%]:=1;
	else
		stimClasses%[iSS%]:=2;
	endif
	'
	stimPctReinf%[iSS%]:=100;
	'
	stimPctTo%[iSS%]:=100;
	'
	'stimPctPres[iSS%]:=Round(100/numStimFiles%);
    
    var nsfbig:= numStimFiles%*10000; 'BURUNGHACK TODO: FIX ME!!!!!
    'stimPctPres[iSS%]:=100/numStimFiles%; 'BURUNGHACK
    stimPctPres[iSS%]:=100.0/nsfbig; 'BURUNGHACK
	stimPctPres[iSS%]:=stimPctPres[iSS%]*10000; 'BURUNGHACK
    'TODO: arrsum check here that it adds up to 100 percent
	'
	stimCodes%[iSS%]:=iSS%;
next;
'
return 1
end
'
func AskStimFile%()
var usestimFile%:=0,currViewASF%,currentPathASF$,numstimFs%,dumName$,stimHandle%;
'
currViewASF%:=View();         'take note of the current view
currentPathASF$:=FilePath$(); 'take note of the current path
'
if InStr(stimFileFullName$,"AskMe") <> 0 then  'there was no stim file loaded in the protocol file
	'
	DlgCreate("Use stim File?",30,.1,0,4,-1,0);
	DlgText("\t\t\t\tUse stim File?\n\n(If not, all '.wav' files in stim folder will be loaded and given default operant parameters.)",0,1);
	DlgButton(1, "Yep, Use a stim file.");
	DlgButton(0, "Nope, Use '.wav' files in stim folder - give default operant parameters.");
	usestimFile%:= DlgShow();
	'
	if usestimFile% then 'pick a stim file here
		FilePathSet(stimPath$);
		numstimFs%:=FileList(dumName$,-1,"*.stim");
		if numstimFs%=1 then
			stimHandle%:=FileOpen(dumName$,8,0);
		else
			stimHandle%:=FileOpen("*.stim",1,0,"Pick Stimulus File to Use");
		endif
		if stimHandle% < 0 then
			PL(Print$("Error opening Stimulus File. Error:\t%s",Error$(stimHandle%)));
			return stimHandle%;
		else
			stimFileName$:=View(stimHandle%).FileName$(3)+View(stimHandle%).FileName$(4);
			stimFileFullName$:= View(stimHandle%).FileName$(0);
			PL(Print$("Using Stimulus File: %s",stimFileFullName$));
			
			View(currViewASF%);
			FilePathSet(currentPathASF$);
			View(stimHandle%).FileClose(0);
		endif
	else
		stimFileFullName$ := "NoStimFileDesired";
	endif
else  'checking to make sure that the stim file indicated in the protocol file is valid
	if InStr(stimFileFullName$,"NoStimFileDesired") = 0 then
		FilePathSet(stimPath$);
		stimHandle%:=FileOpen(stimFileFullName$,8,0);
		if stimHandle% < 0 then
			PL(Print$("Error opening Stimulus File. Error:\t%s",Error$(stimHandle%)));
			return stimHandle%;
		else
			stimFileName$:=View(stimHandle%).FileName$(3)+View(stimHandle%).FileName$(4);
			stimFileFullName$:= View(stimHandle%).FileName$(0);
			PL(Print$("Using Stimulus File: %s",stimFileFullName$));
			View(currViewASF%);
			FilePathSet(currentPathASF$);
			View(stimHandle%).FileClose(0);
		endif
	endif
endif
'
return 1;
end
'
func LoadStimFileStims%(&stimulusfilename$)
var LSFsuccess% := 1,numPStims%:=-1,stimHandle%;
var currviewLSFS% := View();
InitializeStimVariables();

if VERBOSELOG%=1 then PrintLog("In LoadStimFileStims%% attempting to get stims from file: %s\n", stimulusfilename$); endif

stimHandle%:=FileOpen(stimulusfilename$,8,0);

if stimHandle% < 0 then
	PL(Print$("Error opening Stimulus File. Error:\t%s",Error$(stimHandle%)));
	return 0;
endif

var readret% := 1;
while readret% > 0 do'read through all the stim info
	numPStims% += 1;
	readret%:=read(stimFileNames$[numPStims%],stimClasses%[numPStims%],stimPctPres[numPStims%],stimPctReinf%[numPStims%],stimPctTo%[numPStims%]);
	if readret%<0 then
		if readret% <> -1530 then '-1530 is end of file code
			PrintLog("Error reading line %d. Error:\t%s\n",numPStims%+1,Error$(readret%));
			LSFsuccess%:=-1;
		else
			numPStims% -= 1;                                                                                                          
			if VERBOSELOG%=1 then PrintLog("Reached the end of stim file: %s\n",protFileName$); endif
		endif
	else
		stimCodes%[numPStims%]:=numPStims%; 'Set diff code for each stim
		if VERBOSELOG%=1 then PrintLog("Successfully read %d variables from line %d of stimulus file: %s\n",readret%,numPStims%,View(stimHandle%).FileName$(3)+View(stimHandle%).FileName$(4)); endif
	endif
wend
numStimFiles%:=numPStims%+1;
View(stimHandle%);
FileClose();
View(currviewLSFS%);
'
'Check to make sure that all the stim files called for in the protocol file are present and converted to .smr format
var iSPS%,truncNameSPS$,testSPS$,dummySPS$,retSPS$,errSPS%;
for iSPS% := 0 to numStimFiles%-1 do
	truncNameSPS$ := DelStr$(stimFileNames$[iSPS%],InStr(stimFileNames$[iSPS%],stimExt$),Len(stimExt$));
	testSPS$ := truncNameSPS$+datafileextension$;
	if(FileList(dummySPS$,0,testSPS$)) then
		stimFileNames$[iSPS%]:=testSPS$;
		if VERBOSELOG%=1 then PrintLog("In LoadStimFileStims%:\tSpike2 file '%s' already exists, and was not converted\n", stimFileNames$[iSPS%]); endif
	else
		if VERBOSELOG%=1 then PrintLog("In LoadStimFileStims%:\tLoading '%s' from StimLib and Converting to ... ",stimFileNames$[iSPS%]); endif
        if App(-1)>799 then        
            retSPS$ :=FileConvert$(stimLibPath$+stimFileNames$[iSPS%],stimPath$+truncNameSPS$,1,errSPS%);
        else
            retSPS$ :=FileConvert$(stimLibPath$+stimFileNames$[iSPS%],stimPath$+truncNameSPS$,2,errSPS%);
        endif		
        
		if errSPS%=0 then
			PrintLog("'%s'\n",retSPS$);
			stimFileNames$[iSPS%]:=testSPS$;
		else     'if can't find it in the stimlib then look in the subject's stim path
            if App(-1)>799 then        
                retSPS$ :=FileConvert$(stimPath$+stimFileNames$[iSPS%],stimPath$+truncNameSPS$,1,errSPS%);
            else
                retSPS$ :=FileConvert$(stimPath$+stimFileNames$[iSPS%],stimPath$+truncNameSPS$,2,errSPS%);
            endif
			
			if errSPS% = 0 then
				PrintLog("'%s'\n",retSPS$);
				stimFileNames$[iSPS%]:=testSPS$;
			else
				PrintLog("FAILURE! couldn't convert file %s, error: %s\n",stimFileNames$[iSPS%],Error$(errSPS%));
				LSFsuccess%:=-1;
			endif
			
		endif;
	endif;
next
'
return LSFsuccess%;
end
'
proc ConvertStimFiles()
if VERBOSELOG%=1 then PL("Entering ConvertStimFiles"); endif
var n%,iCSF%,stimFileNames$[maxStims%],err%,retCSF$,truncName$,dummyCSF$,testCSF$,errCSF%;

FilePathSet(stimPath$);
n% := FileList(stimFileNames$[],-1,"*"+stimExt$);
for iCSF% := 0 to n%-1 do
    truncName$ := DelStr$(stimFileNames$[iCSF%],InStr(stimFileNames$[iCSF%],stimExt$),Len(stimExt$));
    'check to see if the converted file already exists
    testCSF$ := truncName$+datafileextension$;
    if(FileList(dummyCSF$,0,testCSF$)) then
		if VERBOSELOG%=1 then  PrintLog("In ConvertStimFiles:\tSpike2 file '%s' already exists, '%s' not converted\n", testCSF$, stimFileNames$[iCSF%]); endif
    else
		if VERBOSELOG%=1 then   PrintLog("In ConvertStimFiles:\tConverting '%s' to ... ",stimFileNames$[iCSF%]); endif
        if App(-1)>799 then        
            retCSF$ := FileConvert$(stimFileNames$[iCSF%],truncName$,1,errCSF%);
        else
            retCSF$ := FileConvert$(stimFileNames$[iCSF%],truncName$,2,errCSF%);
        endif
        if errCSF%=0 then
            PrintLog("'%s'\n",retCSF$);
        else
            PrintLog("FAILURE! couldn't convert file %s, error: %s\n",stimFileNames$[iCSF%],Error$(errCSF%));
        endif;
    endif;
next;
numStimFiles% := FileList(stimFileNames$[],0,"*"+datafileextension$); 'loads stimFileNames$ with .smr versions
end;
'
func UpdateStimParams%()
'this will update the stimulus parameters by class if they are updated in the protocol file.
var success% :=1,currstim%,currclass%;
'
for currstim% := 0 to numStimFiles% - 1 do
	currclass% := stimClasses%[currstim%];
	if currclass% < 0 then  'TODO: WARNING MAJOR HACK
		currclass% := 0;
	endif
	
	'	
	if desPctPres[currclass%] >= 0 then
		stimPctPres[currstim%] := desPctPres[currclass%];
	endif
	'
	if  desPctReinf%[currclass%] >= 0 then
		stimPctReinf%[currstim%] := desPctReinf%[currclass%];
	endif
	'
	if desPctTo%[currclass%] >= 0 then
		
		stimPctTo%[currstim%] := desPctTo%[currclass%];
	endif			
next
'
return success%;
end
'
func FinalizeStims%()
var success% := 1;
'
PrintLog("\nFound %d stimulus files\n",numStimFiles%);
PrintLog("Stimulus Name\t\t\tTime(s)\tClass\t%%Feed\t%%TO\t%%Presentation\tStimCode\n");
var stimNum%;
for stimNum% := 0 to numStimFiles%-1 do
	totpres%+=stimPctPres[stimNum%];
next;
var totrndplist%:=0,nnStim%;
for stimNum% := 0 to numStimFiles%-1 do
	searchStimsEnabled%[stimNum%]:=1; 'BH
	blockStimsEnabled%[stimNum%]:=1; 'BH
	stimTimes[stimNum%]:=GetStimTime(stimFileNames$[stimNum%]);
	rndplist%[0]:=totpres%;
	for nnStim%:=0 to Round(stimPctPres[stimNum%])-1 do
		totrndplist%+=1;	
		rndplist%[totrndplist%]:=stimNum%; 'rndplist will be an array with zeroth element being number of subsequent entries, and each subsequent entry being the stimNum of a stim
    next
	stimPctPres[stimNum%]/=totpres%;
	if Len(stimFileNames$[stimNum%]) < 8 then
		PrintLog("%s\t\t\t\t%2.2f\t%d\t%d\t%d\t    %2.1f\t\t%d\n",stimFileNames$[stimNum%],stimTimes[stimNum%],stimClasses%[stimNum%],stimPctReinf%[stimNum%],stimPctTo%[stimNum%],stimPctPres[stimNum%]*100.0,stimCodes%[stimNum%]);
	else
		if Len(stimFileNames$[stimNum%]) < 16 then 
			PrintLog("%s\t\t\t%2.2f\t%d\t%d\t%d\t    %2.1f\t\t%d\n",stimFileNames$[stimNum%],stimTimes[stimNum%],stimClasses%[stimNum%],stimPctReinf%[stimNum%],stimPctTo%[stimNum%],stimPctPres[stimNum%]*100.0,stimCodes%[stimNum%]);
		else
			PrintLog("%s\t\t%2.2f\t%d\t%d\t%d\t    %2.1f\t\t%d\n",stimFileNames$[stimNum%],stimTimes[stimNum%],stimClasses%[stimNum%],stimPctReinf%[stimNum%],stimPctTo%[stimNum%],stimPctPres[stimNum%]*100.0,stimCodes%[stimNum%]);
		endif
		
	endif	
next;
PrintLog("\n");
maxstimlength:=stimTimes[Max(stimTimes[])];
if qMC% <> 1 then
    relE:=maxstimlength+RESPWIN+Max(FEED,TIMEOUT)+ITI;
    relENO:=maxstimlength+MAXITINO;
else
    relE:=(maxstimlength*MCmaxnummots%)+RESPWIN+Max(FEED,TIMEOUT)+ITI;
    relENO:=(maxstimlength*MCmaxnummots%)+MAXITINO; 
endif    
var roundTo := 1000;
relE:=relE*roundTo;
relE:=ceil(relE)/roundTo;
relENO:=relENO*roundTo;
relENO:=ceil(relENO)/roundTo;
'
return success%
end
'
'----------
'
'**********
func SEsetupStimSelectStyle%(inStyle%)
var retSTDlg%,whichStyle%:=0; 
var stimStyleList$[3];
'
if inStyle% <0 then
    DlgCreate("Pick Stim Selection Style",30,.1,0,6,-1,0);
    stimStyleList$[0] := "'Search Stims'                   (loop in order)";
    stimStyleList$[1] := "Do a Block                       (pseudo-random order, at least n repeats)";
    stimStyleList$[2] := "Random Stim Selection    (presentation probability given by protocol file or default values)";
    DlgText("Pick Stim Selection Style:",0,1);
    DlgList(1,70,stimStyleList$[],10,2,2);
    
    if qhRecordingAndBehavior% or qhBehavOnly% then
        DlgCheck(2,"Enable correction trials?",2,3);
        DlgCheck(3,"Stop trial if bird pecks during playback?",2,4);
        retSTDlg% := DlgShow(whichStyle%,correctionTrialsOn%,peckStopOn%);
    else
        retSTDlg% := DlgShow(whichStyle%);
    endif
    
    if retSTDlg%=0 then	
        return 0;
    endif
else
    whichStyle% := inStyle%;
endif


if peckStopOn% = 1 then
	docase
	case InStr(behType$,"2AC")<>0 then
		chronNBseq$ := chronNBseq2ACPS$; 'Use proper sequencer file
	case InStr(behType$,"GNG")<>0 then
		chronNBseq$ := chronNBseqGNGPS$; 'Use proper sequencer file	
	else
	endcase
	SampleSequencer(chronNBseq$);
	PL(Print$("Peckstop on = %d. Sequencer changed to: %s",peckStopOn%,SampleSequencer$()));
endif

docase
case whichStyle%=0 then	''Search Stims' (loop in order)
	qSearching%:=1;
	qSelectRandly%:=0;
	qDoBlocks%:=0;
	qNeedNewBlock%:=0;
	SetLoop(0,1);
	ToolbarEnable(SELECTACTIVESTIMSID%,1);
case whichStyle%=1 then	'Do a Block (psuedo-random order, at least n repeats)
	qDoBlocks%:=1;
	qSearching%:=0;
	qSelectRandly%:=0;
	qNeedNewBlock%:=1;
case whichStyle%=2 then	'Pick random stim, (presentation probability given by protocol file or default values)
	qSelectRandly%:=1;	
	qSearching%:=0;
	qDoBlocks%:=0;
	qNeedNewBlock%:=0;
else
endcase
return 1;
end
'----------
'
'**********
func SEdoEpochInfo%(&subjectInfoHandle%)
var epochMode$:="DunnoMode";
var epochStimSelStyle$;
var currViewDS%;
var epochtime$;
var copiedScriptSeqFile% :=0;
'
'subjectInfoHandle%:=FileOpen(subjectpath$+subjectID$+".SubjectInfo",8,2);
'if subjectInfoHandle% <= 0 then
'	WarnDlg("Couldn't open Subject Info file","In SEdoEpochInfo%, couldn't open Subject Info file.");
'	return 0;
'endif

if qhBehavOnly% then
	epochMode$ := "BO"; 'BO = Behavior Only
else
	if qhRecordingAndBehavior% then
		epochMode$ := "NB"; 'NB = Neural & Behavior
	else
		if qhRecordingOnly% then
			epochMode$ := "NO"; 'NO = Neural Only
		endif
	endif
endif

if qSelectRandly% then
	epochStimSelStyle$ := "R"; 'R = Random Stim Selection
else
	if qDoBlocks% then
		epochStimSelStyle$ := "B"; 'B = Block
	else
		if qSearching% then
			epochStimSelStyle$ := "S"; 'S = Search
		endif
	endif
endif

epochNum% := epochNum% + 1;

var epcSec%,epcMin%,epcHour%,epcDay%,epcMonth%,epcYear%;
TimeDate(epcSec%,epcMin%,epcHour%,epcDay%,epcMonth%,epcYear%);
epochtime$ := Print$("%04d-%02d-%02d+%02d-%02d-%02d",epcYear%,epcMonth%,epcDay%,epcHour%,epcMin%,epcSec%);
'epochtime$ := Print$("%02d%02d%02d-%02d%02d",epcMonth%,epcDay%,epcYear%-2000,epcHour%,epcMin%); 'Watch out for the year 2100 bug!
epochInfo$ := Print$("Epc%02d_%s_%s_%s",epochNum%,epochtime$,epochMode$,epochStimSelStyle$);
DlgCreate("Epoch Comments",30,.1,0,3,-1,0);
DlgString(1,"Epoch Comments: ",200);
'
if not DlgShow(currepochcomments$) then
	currepochcomments$ := "";
endif
'Write to subject info file	
View(subjectInfoHandle%).Print("\n------\n");
View(subjectInfoHandle%).Print("\n\"%s\",\"Epoch\",\"%s\",%d,\"%s\"\n",GetTimeStamp$(),epochInfo$,epochNum%,currepochcomments$);
View(subjectInfoHandle%).FileSave();
'

PL(Print$("New Epoch Started:\n\"%s\",\"Epoch\",\"%s\",%d,\"%s\"\n",GetTimeStamp$(),epochInfo$,epochNum%,currepochcomments$));
dataPathEpoch$:=dataPathRecordingSite$+epochInfo$+"\\";
if FilePathSet(dataPathEpoch$,0,1) <0 then
	WarnDlg("Cannot set epoch path","Cannot set epoch path, likely saving to recording site path.");	
	dataPathEpoch$ := dataPathRecordingSite$;	
	FilePathSet(dataPathEpoch$,0,1);
endif

PL(Print$("File Path Set to: %s",dataPathEpoch$));
copiedScriptSeqFile% := CopyScriptSeqToDir%(dataPathEpoch$);
'
return 1;
end
'----------
'
'*******##END## START EPOCH FUNCTIONS*******
'=======================================================================================================
'
'
var rptsItemnum%,rptstxtItemnum%,maxTItemnum%,totTItemnum%,toLog$;
func SelectActiveStims%(enabledStims%[],titleSAS$,qDoBlocks%) 'TODO: now set up for search stims or block stims, not yet for rand stims (will need a bit of work, since rand plist array is diff)
var iSAS%,ySAS%,xSAS%,retSAS%;
var ncols%:=4,spaceSize%:=30,checkName$;
var answersSAS%[numStimFiles%];

DlgCreate(titleSAS$,30,.1,(ncols%*spaceSize%),0,-1,0);

for iSAS% := 0 to numStimFiles%-1 do
	answersSAS%[iSAS%]:=enabledStims%[iSAS%]; 'load currently active stims into dialogue
	checkName$:=stimFileNames$[iSAS%];
	checkName$:=Left$(checkName$,InStr(checkName$,datafileextension$)-1) + Print$(" (%.4f s)",stimTimes[iSAS%]);
	'if doCurr% and iSAS%=searchInd% then 'doCurr for allowing the current stim to be a choice, not implementing yet
	'	checkName$:=checkName$+" (*)";
	'endif;
	ySAS%:=1+trunc((iSAS%)/ncols%);
	xSAS% := (((iSAS%+1)-((ncols%)*(ySAS%-1))-1)*spaceSize%)+5;
	DlgCheck(iSAS%+1,checkName$,xSAS%,ySAS%); 'dialogue items 1:numstimfiles should be stim checkboxes; value= 0 or 1
next;

DlgButton(2,"Select all",SelectAllSAS%,((ncols%*spaceSize%)/2)+5,ySAS%+1.5); 
DlgButton(3,"Clear all",ClearAllSAS%,((ncols%*spaceSize%)/2)-15,ySAS%+1.5);

if qDoBlocks% = 1 then
	rptsItemnum% := numStimFiles%+1;
	rptstxtItemnum%:=DlgText("Number of repeats per block:",((ncols%*spaceSize%)/3)-0,ySAS%+3);
	DlgInteger(rptsItemnum%,10,1,MAXREPEATS%,((ncols%*spaceSize%)/3)+35,ySAS%+3,1);
	maxTItemnum%:=DlgText("Time per repeat:",((ncols%*spaceSize%)/3)-0,ySAS%+4,50); 
	totTItemnum%:=DlgText("Total time:",((ncols%*spaceSize%)/3)-0,ySAS%+5,50); 
	DlgText("Above times are for stimulus, operant time variables only.",((ncols%*spaceSize%)/3)-0,ySAS%+6);
	DlgText("        Actual times depend on bird's behavior.",((ncols%*spaceSize%)/3)-0,ySAS%+7);
	DlgAllow(0,0,UpdateDialogue%);
	retSAS% := DlgShow(answersSAS%[],numBlockRepeats%);
else
	retSAS% := DlgShow(answersSAS%[]);
endif

if retSAS% then
	var atLeastOne%:=0;
	for iSAS% :=0 to numStimFiles%-1 do
		if not atLeastOne% then
			atLeastOne%:=answersSAS%[iSAS%];
		endif;
    next;
	if not atLeastOne% then
		Message("At least one stim must be enabled.");
		retSAS% := SelectActiveStims%(enabledStims%[],titleSAS$,qDoBlocks%);
	else
		for iSAS% :=0 to numStimFiles%-1 do
			enabledStims%[iSAS%]:=answersSAS%[iSAS%];
			'PrintLog("stim %d:%d\n", i%,en%[i%]);
        next;
	endif
else
	if qDoBlocks% = 1 then
		PL("Block Setup Cancelled");
		StopRecordingandSave%(1); '1 forces sampling to stop
		return 2; 'this will signal 'block cancelled'
	endif
endif

return retSAS%;
end
'
func SelectAllSAS%()
var iSA%;
for iSA% :=1 to numStimFiles% do
	DlgValue(iSA%,1);
next;
'if DlgValue(numStimFiles%+1) then
'	UpdateDialogue%(0);
'endif;
return 1;
end;

'
func ClearAllSAS%()
var iCA%;
for iCA% :=1 to numStimFiles% do
	DlgValue(iCA%,0);
next;
'if DlgValue(numStimFiles%+1) then
'	UpdateDialogue%(0);
'endif;
return 1;
end;
'
'***************************
'***#BEGIN# OPERANT STUFF***
'***************************
func CheckDigChan%(desiredCode%)
var cdcCodes%[4],cdcReturn%:=0;
'
if currSeekTime < lastEventTime then
	currSeekTime := lastEventTime;
endif;
'
currSeekTime := View(datahandle%).NextTime(32,currSeekTime,cdcCodes%[]);
'
if cdcCodes%[0] = desiredCode% then
	if VERBOSELOG%=1 then PL(Print$("Found desired code: %d",desiredCode%)); endif
	lastEventTime := currSeekTime;
	cdcReturn%:=1;
endif;
'
return cdcReturn%
end;
'
func UpdateOpDatTrial%(&trialoutcome%[]) 'consciously not going with ndege format so that can keep trial timing information.  possible write a conversion function that takes this opdat data and makes it ndege style? (see SM_readS2opdat_2ac.m)
'fills trialoutcome%[] with:
'trialoutcome%[0] = outcome of trial: 0 = incorrect ; 1 = correct ; 2 = noresponse
'trialclass%[1] = class of stimulus
'trialoutcome%[2] = correction trial (0 = not correction trial, 1 = correction trial)

var keyTime:=-0.5;
var opTime;
var tmTime;
var keyCodes%[4];
var opCodes%[4];
var tmCodes%[4];
var endit%:=0;
var tmString$;
var currViewUOD%;
var currPathUOD$;
var retUOD%;

'currViewUOD%:=View();
if qhRecordingAndBehavior% or qhBehavOnly% then
	if opDatHandle% < 0 then
		ToolbarEnable(CHECKOPERANTDATAID%,1);
		currPathUOD$:=FilePath$();
		FilePathSet(dataPathRoot$);
		opDatHandle%:=FileNew(1,0);
		Print("%s:\tSampling started. All times below are relative to this time in seconds.\n\n",View(datahandle%).FileTime$(1,7,0,":"));
		View(opDatHandle%).FileSaveAs(Date$(2,2,1,1,"-")+"+"+Time$(1,7,0,"-")+"-opdat.txt",1);
		FilePathSet(currPathUOD$);
		opDatName$:=View(opDatHandle%).FileName$(0);
		View(opDatHandle%).Window(0,1,50,52.5,1);
	endif
endif

View(datahandle%);
keyTime:=View(datahandle%).NextTime(31,lastTrialEndTime,keyCodes%[]);
if keyCodes%[0] = 0 then '"00"
	keyTime:=View(datahandle%).NextTime(31,keyTime,keyCodes%[]);
endif
'repeat 
if keyCodes%[0] = 83 then '"S"
	if qhRecordingAndBehavior% or qhBehavOnly% then
		View(opDatHandle%).Print("%4.2f:\tTrial setup, sequencer signaled.\n",keyTime);
	endif
	opTime:=View(datahandle%).NextTime(32,keyTime,opCodes%[]);
	while endit% <> 1 and opTime > -1 do
		docase
		case opCodes%[0] = 60 then
			tmTime:=View(datahandle%).NextTime(30,opTime-0.1,tmCodes%[],tmString$); 	'Found Timestamp code. Skip it. 'TODO: check to make sure this IS the timestamp marker
			currtrialstarttime := tmTime;
			tmTime:=View(datahandle%).NextTime(30,tmTime,tmCodes%[],tmString$); 		'This should be the stimID textmark
			trialoutcome%[1] := tmCodes%[1]; 'stim class
			trialoutcome%[2] := tmCodes%[2]; 'correction trial? (1=yes)
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\t**Trial Started:\t%s\tclass %d\n",opTime,tmString$,tmCodes%[1]);
				opData%[tmCodes%[0]][0]+=1;
			endif
		case opCodes%[0] = 62 then '">"
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\tStimulus output stopped\n",opTime);
			endif
		case opCodes%[0] = 35 then '"#"
			View(opDatHandle%).Print("%4.2f:\tStimulus output Prematurely stopped\n",opTime);
			if correctionTrialsOn% = 1 then
				doCorrectionTrial% := 1;
			endif
		case opCodes%[0] = 70 then '"F"
			View(opDatHandle%).Print("%4.2f:\tFeed Started\n",opTime);
			opData%[tmCodes%[0]][1]+=1; 'increment correct
			opData%[tmCodes%[0]][2]+=1; 'increment feeds
			trialoutcome%[0] := 1;  'mark correct for output
			trialoutcome%[4] := 1; 	'mark 1 for reinforced
			docase
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 1 then
				trialoutcome%[3] := 1;  'mark 1 for left peck
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 2 then
				trialoutcome%[3] := 2;  'mark 2 for right peck
			else
				Message("Need to recode for more than 2 effective stimulus classes, Halting.");	
				halt;				
			endcase
			
			if correctionTrialsOn% = 1 then
				doCorrectionTrial% := -1;	'reset correction trial status
				View(opDatHandle%).Print("%4.2f:\tCorrection trials turned on\n",opTime);
			endif
		case opCodes%[0] = 102 then '"f"
			View(opDatHandle%).Print("%4.2f:\tCorrect but no feed\n",opTime);
			opData%[tmCodes%[0]][1]+=1; 'increment correct
			trialoutcome%[0] := 1;  'mark correct for output
			trialoutcome%[4] := 0; 	'mark 0 for reinforced
			docase
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 1 then
				trialoutcome%[3] := 1;  'mark 1 for left peck
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 2 then
				trialoutcome%[3] := 2;  'mark 2 for right peck
			else
				Message("Need to recode for more than 2 effective stimulus classes, Halting.");	
				halt;				
			endcase
			if correctionTrialsOn% = 1 then
				doCorrectionTrial% := -1;	'reset correction trial status;
				View(opDatHandle%).Print("%4.2f:\tCorrection trials turned off\n",opTime);
			endif
		case opCodes%[0] = 125 then '"}"
			View(opDatHandle%).Print("%4.2f:\tFeed Over\n",opTime);
		case opCodes%[0] = 84 then '"T"
			View(opDatHandle%).Print("%4.2f:\tTimeout Started\n",opTime);
			opData%[tmCodes%[0]][3]+=1; 'increment incorrect
			opData%[tmCodes%[0]][4]+=1; 'increment timeouts
			trialoutcome%[0] := 0;  'mark incorrect for output
			trialoutcome%[4] := 1; 	'mark 1 for reinforced
			docase
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 1 then
				trialoutcome%[3] := 2;  'mark 2 for right peck
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 2 then
				trialoutcome%[3] := 1;  'mark 1 for left peck
			else
				Message("Need to recode for more than 2 effective stimulus classes, Halting.");	
				halt;				
			endcase
			if correctionTrialsOn% = 1 then
				doCorrectionTrial% := 1;	'set flag for correction trials
				View(opDatHandle%).Print("%4.2f:\tCorrection trials turned on\n",opTime);
			endif
		case opCodes%[0] = 116 then '"t"
			View(opDatHandle%).Print("%4.2f:\tWrong but no timeout\n",opTime);
			opData%[tmCodes%[0]][3]+=1; 'increment incorrect
			trialoutcome%[0] := 0;  'mark incorrect for output
			trialoutcome%[4] := 0; 	'mark 0 for reinforced
			docase
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 1 then
				trialoutcome%[3] := 2;  'mark 2 for right peck
			case GetEffectiveStimClass%(stimClasses%[currStim%]) = 2 then
				trialoutcome%[3] := 1;  'mark 1 for left peck
			else
				Message("Need to recode for more than 2 effective stimulus classes, Halting.");	
				halt;				
			endcase
			if correctionTrialsOn% = 1 then
				doCorrectionTrial% := 1;	'set flag for correction trials
				View(opDatHandle%).Print("%4.2f:\tCorrection trials turned on\n",opTime);
			endif
		case opCodes%[0] = 93 then '"]"
			View(opDatHandle%).Print("%4.2f:\tTimeout Over\n",opTime);
		case opCodes%[0] = 76 then '"L"
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\t\tPeck Left\n",opTime);
			endif
			
		case opCodes%[0] = 67 then '"C"
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\t\tPeck Center\n",opTime);
			endif
		case opCodes%[0] = 82 then '"R"
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\t\tPeck Right\n",opTime);
			endif
		case opCodes%[0] = 78 then '"N"
			View(opDatHandle%).Print("%4.2f:\tResponse Window Passed, No Response\n",opTime);
			opData%[tmCodes%[0]][5]+=1; 'increment no responses
			trialoutcome%[0] := 2;  'mark no response for output
			trialoutcome%[3] := 0;  'mark 0 for no peck
			trialoutcome%[4] := 0;  'mark 0 for reinforced
			if InStr(behType$,"GNG")<>0 then
				if stimClasses%[currStim%] = 2 then
					doCorrectionTrial% := -1;	'reset correction trial status;
				endif
			endif
		case opCodes%[0] = 40 then '"("
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\tITI started\n",opTime);	
			endif				
		case opCodes%[0] = 41 then '")"
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\t**ITI over. End of Trial.\n\n",opTime);
			endif
			endit%:=1;
		else
			if qhRecordingAndBehavior% or qhBehavOnly% then
				View(opDatHandle%).Print("%4.2f:\tcode: %d\n",opTime,opCodes%[0]);
			endif
		endcase
		opTime:=View(datahandle%).NextTime(32,opTime,opCodes%[]);
    wend;
	endit%:=0;
endif
if qhRecordingAndBehavior% or qhBehavOnly% then
	View(opDatHandle%).FileSaveAs(opDatName$,1,1);
endif
'FrontView(currViewUOD%);
return 1;
end
'
func CheckOpdata%();
var numpres%;
var CODHandle%:=-1;
'var currViewCOD%;
var currPathCOD$;
'currViewCOD%:=View();
'
if CODHandle% < 0 then
	currPathCOD$:=FilePath$();
	FilePathSet(dataPathRoot$);
	CODHandle%:=FileNew(1,1);
	WindowTitle$(Print$("<Operant Data Check> %s",View(datahandle%).Time$(1,7,0,":")));
	Print("%s:  Operant Data Check\n",View(datahandle%).Time$(1,7,0,":"));
	'View(CODHandle%).FileSaveAs(Date$(2,2,1,1,"-")+"+"+Time$(1,7,0,"-")+"-opdat.txt",1);
	FilePathSet(currPathCOD$);
	'opDatName$:=View(opDatHandle%).FileName$(0);
	View(CODHandle%).Window(0,1,40,40);
endif

Print("\nSummary Data: Since %s\n",currentEpochStartDateTime$);
Print("Stimulus\t\t#pres\t#corr\t#feeds\t#incorr\t#TOs\t#noResp\n");
var iCOD%;
if qMC% <> 1 then
    for iCOD% := 0 to numStimFiles%-1 do
        if Len(stimFileNames$[iCOD%]) < 8 then
            Print("%s\t\t\t%d\t%d\t%d\t%d\t%d\t%d\n",stimFileNames$[iCOD%],opData%[iCOD%][0],opData%[iCOD%][1],opData%[iCOD%][2],opData%[iCOD%][3],opData%[iCOD%][4],opData%[iCOD%][5]);
        else
            if Len(stimFileNames$[iCOD%]) < 16 then
                Print("%s\t\t%d\t%d\t%d\t%d\t%d\t%d\n",stimFileNames$[iCOD%],opData%[iCOD%][0],opData%[iCOD%][1],opData%[iCOD%][2],opData%[iCOD%][3],opData%[iCOD%][4],opData%[iCOD%][5]);
            else '>=16
                Print("%s\t%d\t%d\t%d\t%d\t%d\t%d\n",stimFileNames$[iCOD%],opData%[iCOD%][0],opData%[iCOD%][1],opData%[iCOD%][2],opData%[iCOD%][3],opData%[iCOD%][4],opData%[iCOD%][5]);
            endif
        endif
    next;
else
    Print("Class 1 (Left)\t\t%d\t%d\t%d\t%d\t%d\t%d\n",opData%[1][0],opData%[1][1],opData%[1][2],opData%[1][3],opData%[1][4],opData%[1][5]);
    Print("Class 2 (Right)\t\t%d\t%d\t%d\t%d\t%d\t%d\n",opData%[2][0],opData%[2][1],opData%[2][2],opData%[2][3],opData%[2][4],opData%[2][5]);
    Print("Class 3 (Ambiguous)\t%d\t%d\t%d\t%d\t%d\t%d\n",opData%[3][0],opData%[3][1],opData%[3][2],opData%[3][3],opData%[3][4],opData%[3][5]);
endif
numpres% := ArrSum(opData%[][0]);
print("\nTotals:\t\t\t%d\t%d\t%d\t%d\t%d\t%d",ArrSum(opData%[][0]),ArrSum(opData%[][1]),ArrSum(opData%[][2]),ArrSum(opData%[][3]),ArrSum(opData%[][4]),ArrSum(opData%[][5]));
print("\nRatios:\t\t\t\t%2.2f\t%2.2f\t%2.2f\t%2.2f\t%2.2f",ArrSum(opData%[][1])/numpres%,ArrSum(opData%[][2])/numpres%,ArrSum(opData%[][3])/numpres%,ArrSum(opData%[][4])/numpres%,ArrSum(opData%[][5])/numpres%);

ToolbarEnable(CLOSEOPCHECKWINID%,1);
return 1;
end
'
proc SaveOpDatFile(assocWDataFile%,dataFileName$,doClose%)
var retSODF%,currViewSODF%,currFilePathSODF$;
currViewSODF%:=View();
currFilePathSODF$:=FilePath$();
View(opDatHandle%);
FilePathSet(dataPathEpoch$);

Print("\n\nSummary Data:\n\n");
Print("Stimulus\t\t#pres\t#corr\t#feeds\t#incorr\t#TOs\t#noResp\n");
var iSODF%;
for iSODF% := 0 to numStimFiles%-1 do
	if Len(stimFileNames$[iSODF%]) < 8 then
		Print("%s\t\t\t%d\t%d\t%d\t%d\t%d\t%d\n",stimFileNames$[iSODF%],opData%[iSODF%][0],opData%[iSODF%][1],opData%[iSODF%][2],opData%[iSODF%][3],opData%[iSODF%][4],opData%[iSODF%][5]);
	else
		Print("%s\t\t%d\t%d\t%d\t%d\t%d\t%d\n",stimFileNames$[iSODF%],opData%[iSODF%][0],opData%[iSODF%][1],opData%[iSODF%][2],opData%[iSODF%][3],opData%[iSODF%][4],opData%[iSODF%][5]);
	endif
next;
print("\nTotals:\t\t\t%d\t%d\t%d\t%d\t%d\t%d",ArrSum(opData%[][0]),ArrSum(opData%[][1]),ArrSum(opData%[][2]),ArrSum(opData%[][3]),ArrSum(opData%[][4]),ArrSum(opData%[][5]));


if assocWDataFile% = 1 then
	retSODF%:=FileSaveAs(dataFileName$+"-opdat.txt",1);
	if retSODF%=0 and doClose%=1 then
		View(opDatHandle%);
		PL(Print$("Opdat file saved successfully as: %s\n\n",FileName$(0)));
		FileClose(0,-1);
		FileDelete(opDatName$);
		opDatHandle% := -1;
	endif
else
	retSODF%:=FileSaveAs(Date$(2,2,1,1,"-")+"+"+Time$(1,7,0,"-")+"-opdat.txt",1);
	if retSODF%=0 and doClose%=1 then
		View(opDatHandle%);
		PL(Print$("Opdat file saved successfully as: %s\n\n",FileName$(0)));
		FileClose(0,-1);
		FileDelete(opDatName$);
		opDatHandle% := -1;
	endif
endif;	
if retSODF%<>0 then
	PrintLog("ERROR: Error saving opdat file: %s\n",Error$(retSODF%));
	WarnDlg("Error saving opdat file","Error saving opdat file. Check file and attempt to save manually");
endif;
FilePathSet(currFilePathSODF$);
View(currViewSODF%);
end;
'
func UpdateAllTrialsFile%(&trialoutcome%[])
var success% := 1;
var filesecondssincemidnight%;
var currview% := View();
'
if AllTrialsHandle% = -1 then    'open alltrials file
	AllTrialsHandle%:=FileOpen(AllTrialsName$,8,2);
	if AllTrialsHandle% <0 then 'does not exist, so create it
		var currPath$:=FilePath$();
		FilePathSet(subjectpath$);
		AllTrialsHandle%:=FileNew(1,0);
		if AllTrialsHandle% <0 then
			WarnDlg("Could not create an AllTrials file, halting.","Could not create an AllTrials file, halting.");
			halt;		
		endif
		PrintLog("%s:\tCreated AllTrials File for %s\n",GetTimeStamp$(),subjectID$);
		Print("##Date,Time,Penetration,Site,Epoch,NeuralRecording,BehavioralRecording,StimClass,Correction,ResponseSelection,ResponseAccuracy,Reinforced,StimName,ProtocolFile,StimulusFile##\n");
		View(AllTrialsHandle%).FileSaveAs(AllTrialsName$,1);
		FilePathSet(currPath$);
	endif
endif

'get values
var ATdate$ := Date$(2,2,3,3,":");
View(datahandle%).FileTimeDate(filesecondssincemidnight%);
var trialsecondssincemidnight% := filesecondssincemidnight% + currtrialstarttime;
var currtrialhours% := Floor(trialsecondssincemidnight%/3600);
var currtrialmins% := Floor((trialsecondssincemidnight% - 3600*currtrialhours%)/60);
var currtrialseconds%:= trialsecondssincemidnight% - currtrialhours%*3600 - currtrialmins%*60;
var ATtime$ := Print$("%02d:%02d:%02d",currtrialhours%,currtrialmins%,currtrialseconds%);
var neuralboolean%:=0;
var behaviorboolean%:=0;
if qhRecordingAndBehavior% or qhRecordingOnly% then
	neuralboolean%:=1;
endif
if qhRecordingAndBehavior% or qhBehavOnly% then
	behaviorboolean%:=1;
endif
var ATstim$:=Left$(stimFileNames$[currStim%],Len(stimFileNames$[currStim%])-4);
View(AllTrialsHandle%);
'write to it
Print("%s,%s,%d,%d,%d,",ATdate$,ATtime$,penetrationNum%,recordingSiteNum%,epochNum%);
Print("%d,%d,%d,%d,%d,%d,%d,%s\n",neuralboolean%,behaviorboolean%,trialoutcome%[1],trialoutcome%[2],trialoutcome%[3],trialoutcome%[0],trialoutcome%[4],ATstim$);
'save it
View(AllTrialsHandle%);
FileSaveAs(AllTrialsName$,1,1);
'close it
View(AllTrialsHandle%);
FileClose(0,-1);
AllTrialsHandle%:=-1;
'reset view
View(currView%);
'
return success%
end
''***************************
'***##END## OPERANT STUFF***
'***************************
'
'************************
'***#BEGIN# VIEW STUFF***
'************************
func SoftRefSetup%()
var tmpview%;
tmpview% := View();
View(datahandle%);
if trodeType% = 0 or trodeType% = 1 or trodeType% = 4 then	
	var currRefChan%,currChan%;
	currWFChan%[0] := 17;
	currVChan%[0]  := 17;
	DlgCreate("Pick reference channel",30,0.1,0,3); 'pick channel to use as ref	
	DlgList(1,"Pick reference channel:","1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16");
	DlgShow(currRefChan%);
	for currChan% := 1 to 16 do
		currVChan%[currChan%] := VirtualChan(0,Print$("ch(%d)-ch(%d)",currChan%,currRefChan%+1),currChan%);
		currWFChan%[currChan%] := currChan%;
    next;
	ChanShow(currVChan%[]);
	ChanHide(currWFChan%[]);
	Optimise(-2); 
	ToolbarSet(SOFTREFID%,"Cancel Software Referencing",SoftRefCancel%);
else
	WarnDlg("Software Referencing only setup for 16 channels, see SoftRefSetup%","Software Referencing only setup for 16 channels, see SoftRefSetup%");
endif
'
View(tmpview%);
return 1;
end
'
func SoftRefCancel%()
var tmpview1%;
tmpview1% := View();
View(datahandle%);
ChanDelete(currVChan%[]);
ChanShow(currWFChan%[]);
ToolbarSet(SOFTREFID%,"Setup Software Referencing",SoftRefSetup%);
View(tmpview1%);
return 1;
end
'
func CARSetup%()
var tmpview%;
tmpview% := View();
View(datahandle%);
if trodeType% = 0 or trodeType% = 1 or trodeType% = 4 or trodeType% = 7 then	
	var currRefChan%;
	currWFChan%[0] := 17;
	currVChan%[0]  := 17;
	DlgCreate("Pick Chan to CAR (will use those currently selected as References)",30,0.1,0,3); 'pick channel to use as ref	
	DlgList(1,"Pick Chan to CAR:\n(will use those currently selected as References)","1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16");
	DlgShow(currRefChan%);
	
	var refsCAR%[500];
	ChanList(refsCAR%[],65536); 'picks all selected channels
	currCARChan%[numCARs%+1] := MakeCARChannel%(currRefChan%+1,refsCAR%[]);
	numCARs%+=1;
	currCARChan%[0] := numCARs%;
	ToolbarEnable(CARCANCELID%,1);
else
	WarnDlg("Software Referencing only setup for 16 channels, see SoftRefSetup%","Software Referencing only setup for 16 channels, see SoftRefSetup%");
endif
'
View(tmpview%);
return 1;
end
'
func MakeCARChannel%(chan%,carChans%[])
var currChan%;
View(datahandle%);
var vChan%,vExpression$;

vExpression$:=Print$("ch(%d)-((",chan%);
for currChan% := 1 to carChans%[0] do
	if carChans%[currChan%] <> chan% then
		vExpression$ += Print$("ch(%d)+",carChans%[currChan%]);
	endif		
next;
vExpression$ += Print$("0)/%d)",carChans%[0]);
vChan% := VirtualChan(0,vExpression$,chan%);
ChanTitle$(vChan%,Print$("ch%d-CAR",chan%));
Optimise(vChan%);
ChanShow(vChan%);

return vChan%;
end
'
func CARCancel%()
var tmpview1%;
tmpview1% := View();
View(datahandle%);
ChanDelete(currCARChan%[]);
numCARs%:=0;
currCARChan%[0]:=numCARs%;
ToolbarEnable(CARCANCELID%,0);
View(tmpview1%);
return 1;
end
'
func DoLoadEpcView%()
if InStr(lastEpochView$,"epochView.s2r") <> 0 then
	FileApplyResource(lastEpochView$);
endif
return 1;
end
'************************
'***##END## VIEW STUFF***
'************************
'
'***********************
'***#BEGIN# UTILITIES***
'***********************
proc StartupScript()
'Clear and place log window, startup log, check 1401 on and run resetbox 
'
'***Clear and place log window***
var mon1%[4],mon2%[4];
View(LogHandle()).EditSelectAll();   'clear the log window
View(LogHandle()).EditClear();       'clear the log window
System(1,1,mon1%[]); 'fills mon1% with pixel size of top monitor
System(1,2,mon2%[]); 'fills mon2% with pixel size of bottom monitor
View(LogHandle()).Window(0,50,50,97,1); 'place log window
FrontView(LogHandle());
'***Done: clear and place log window***
'
'***Startup log file***
var scripthandle%,scriptname$;
scripthandle%:=App(3);
scriptname$:=View(scripthandle%).FileName$(3)+View(scripthandle%).FileName$(4);
PL(Print$("%s.s2s started\n",scriptname$));
'***done: startup log file***
'
'***Check that 1401 is on and run Resetbox***
var checkhandle%;
checkhandle%:=FileNew(0,0);
if checkhandle% < 0 then
	WarnDlg("1401 is off/sampling.","Couldn't create a new data file.\nIs the 1401 on?\nDidn't think so, don't worry it happens to the best of us!\nOh. It is on? Then stop sampling...\nHalting.");	
	halt;
else
	View(checkhandle%);
	FileClose(0,-1);
	ResetBox(); 'This is in the include file
endif
'***done: Check that 1401 is on and run Resetbox***
'
end
'
func PickSubjectPath$(whichFPS%) 
var psubjectpath$,retFPS%;
var defaultsubjectpath$ := expPathRoot$+"testchron\\";
docase
case whichFPS% = 1 then
	psubjectpath$ := defaultsubjectpath$;
case whichFPS% = 2 then
	FilePathSet(defaultsubjectpath$); 'this will set the starting location for FilePathSet() below
	retFPS%:=FilePathSet("",0,"Set subject folder.");
	if retFPS% < 0 then  
		PrintLog(Print$("No file path set...exiting script. Error: %s",Error$(retFPS%)));
		halt; 
	else 
		psubjectpath$ := FilePath$();
	endif;
case whichFPS% = 3 then
	var exppathdesired$,retDS%;
	DlgCreate("Type Experiment Folder (Bird ID)",30,.1,0,2.5,-1,0);
	DlgString(1,"Type Experiment Folder (Usually Bird ID)",50);
	retDS%:=DlgShow(exppathdesired$);
	retFPS%:=FilePathSet(expPathRoot$+exppathdesired$,0,1);
	if retFPS% < 0 or retDS% = 0 then  
		PrintLog("No file path set...exiting script.");
		halt; 
	else 
		psubjectpath$ := FilePath$();
	endif;
endcase
'
return psubjectpath$
end
'
func StopRecordingandSave%(epochStop%)
var retSRAS%,matSRAS%,goSRAS%:=0;
var savename$ := Print$("Sub%sPen%02dSite%02dEpc%02dFile%02d_",subjectID$,penetrationNum%,recordingSiteNum%,epochNum%,datafilenumber%)+FileDate$(2,2,1,1,"-")+"+"+FileTime$(1,7,3,"-")+"_"+subjectID$;

PrintLog("\n");
PL(Print$("Stopping sampling for current data file.\n"));

View(datahandle%);
lastEpochView$:= dataPathEpoch$+"epochView.s2r";
FileSaveResource(lastEpochView$);

View(datahandle%);
if not qisNight% then
    SampleKey(trialResetKey$);
endif
if SampleStop() = 0 then
	lastSizeCheckTime:=-1;
	while goSRAS% = 0 do
		CursorDelete(-1); 'Delete cursors so they don't annoy you when you reopen the file to sort spikes or whatever
		FilePathSet(dataPathEpoch$);
		if not qhBehavOnly% then		
			View(datahandle%).FileComment$(1,Print$("%s",penetrationInfo$));	'TODO: use comments to put info about penetration depth, number, blocks done, which channels saved etc
			View(datahandle%).FileComment$(2,Print$("%s",recordingSiteInfo$));
			View(datahandle%).FileComment$(3,Print$("%s",epochInfo$));
			View(datahandle%).FileComment$(4,Print$("Electrode Type: %s",eTrodeList$[trodeType%]));
			View(datahandle%).FileComment$(5,Print$("Electrode Info: %s\tElectrode Comments:",electrodeInfo$,eTrodeComments$));
			PL(Print$("FileComments:\nPenetration:\t\t%s\nSite:\t\t\t%s\nEpoch:\t\t\t%s\n",penetrationInfo$,recordingSiteInfo$,epochInfo$));				
			PL(Print$("Electrode:\t\t%s\nElectrode Type:\t\t%s\nElectrode Comments:\t%s\n\n",electrodeInfo$,eTrodeList$[trodeType%],eTrodeComments$));				
		endif
		'
		if dosavemicchannelduringBO% = 0 and qhBehavOnly% = 1 then
			ChanDelete(BOmicchannel%);
		endif			
		docase 'TODO: a bit obsolete...fix re: new file structure/multiple files
		case qStopBlock% = 1 then
            savename$ := savename$+"_block-part";
		case qStopBlock% = 2 then
            savename$ := savename$+"_block";
		else
            savename$ := savename$;
		endcase
        retSRAS%:=FileSaveAs(savename$+".smrx",-1,1);
                
		'
		if retSRAS% <> 0 then
			PL(Print$("Error using FileSaveAs.  Error: %s",Error$(retSRAS%)));
			goSRAS%:=0;
		else		
			PL(Print$("\nData file saved successfully as: %s\n\n",FileName$(0)));
			if opDatHandle% >= 0 then
				SaveOpDatFile(1,FileName$(3)+FileName$(4),1);
			endif
			SaveLog(1,FileName$(3)+FileName$(4));
			goSRAS%:=1;
		endif
        
        ExportChanList();                        
        ExportChanList(0,View(datahandle%).MaxTime(),-1);
        matSRAS%:=FileSaveAs(savename$+".mat",100,1,"",0,"UseSName=0|UseCName=1|WaveData=0|WaveAll=1|WaveSameN=1|Compat=4");
        
        if matSRAS% <> 0 then
			PL(Print$("Error exporting to Matlab using FileSaveAs.  Error: %s",Error$(matSRAS%)));
		else		
			PL(Print$("\nData exported to Matlab successfully as: %s\n\n",FileName$(0)));
			SaveLog(1,FileName$(3)+FileName$(4));
		endif
        
    wend
	FrontView(LogHandle());
	View(datahandle%).FileClose(0,-1);
	'
	if epochStop% = 1 then
		ToolbarState("WaitInToolbar");
		PL(Print$("Stopping Current Recording Epoch.\n"));
		ZeroAllFlags();
		ArrConst(opData%[][],0);
		qhInEpoch% := 0;
	else
		ToolbarState("StopRecordingStayEpoch");
		ResetTrialFlags();
		PL(Print$("Closing Current File.  Look for more in this Epoch.\n"));
	endif
	'
	FilePathSet(expPathRoot$,3); 'reset autosave path
	return 1;	'indicates that user stopped recording and everything is in order
else 
	PL("Could not stop sampling");
	WarnDlg("Could Not Stop Sampling","Could not stop sampling!");
	SaveLog(0,"");
	if opDatHandle% >= 0 then
		SaveOpDatFile(0,"",1);
	endif
	halt; 'TODO: do I want to halt here? go back to toolbar or something with appropriate error warning?
endif
end;
'
proc SaveLog(assocWDataFile%,dataFileName$)
var retSL%,currViewSL%,currFilePathSL$;
currViewSL%:=View();
currFilePathSL$:=FilePath$();
View(LogHandle());
FilePathSet(dataPathEpoch$);

if assocWDataFile% = 1 then
	PL(Print$("Attempting to save log as: %s\n\n",dataPathEpoch$+dataFileName$+"-log.txt"));
	retSL%:=FileSaveAs(dataFileName$+"-log.txt",1,1);
	if retSL%=0 then
		View(LogHandle()).EditSelectAll();
		View(LogHandle()).EditClear();
		PL(Print$("Running Script: %s.s2s\n",View(App(3)).FileName$(3)+View(App(3)).FileName$(4)));
		PrintLog("Subject path is set to %s\n\n", subjectpath$);
		PL("In Toolbar");
	endif
else
	PL(Print$("Attempting to save log as: %s\n\n",Date$(2,2,1,1,"-")+"+"+Time$(1,7,0,"-")+"-log.txt"));
	retSL%:=FileSaveAs(Date$(2,2,1,1,"-")+"+"+Time$(1,7,0,"-")+"-log.txt",1,1);
endif;	
if retSL%<>0 then
	PrintLog("ERROR: Error saving log file: %s\n",Error$(retSL%));
	WarnDlg("Error saving log file","Error saving log file. Check log and attempt to save manually");
endif;
FilePathSet(currFilePathSL$);
View(currViewSL%);
end;
'
func CopyScriptSeqToDir%(directorytocopyto$);
var seqname$,seqhandle%,currViewCSSTD%,retseq%,retscr%,scriptfullpathname$,scriptcopyfile$,seqcopyfile$,protcopyfile$,retprot%,stimcopyfile$,retstim%,mastersetstimcopyfile$,retmastersetstim%;
currViewCSSTD% := View();
'
'Save a copy of the script to epoch folder
scriptfullpathname$:=View(App(3)).FileName$(0);
scriptcopyfile$ := directorytocopyto$ + View(App(3)).FileName$(3) + View(App(3)).FileName$(4) + "_autocopy" + ".s2s";
retscr% := FileCopy(scriptfullpathname$, scriptcopyfile$,0);
if retscr% = 1 then
    PrintLog("Saved a copy of the currently selected script file as %s\n", scriptcopyfile$);
else
    PrintLog("Something went wrong copying the script file to the current directory %s\nError is: %s\n",directorytocopyto$,Error$(retscr%));
endif'
'Save a copy of the sequencer file to the epoch folder
'get sequencer file name (minus path info)
seqhandle% := FileOpen(seqfile$,2);
seqname$ := FileName$(3) + FileName$(4) + "_autocopy" + FileName$(5);
FileClose(0,0);
'there
seqcopyfile$ := directorytocopyto$+seqname$; 'make sequencer copy file name
retseq%:=FileCopy(seqfile$,seqcopyfile$,0);
if retseq% = 1 then
    PrintLog("Saved a copy of the currently selected sequencer file as %s\n", seqcopyfile$);
else
    PrintLog("Something went wrong copying the sequencer file to the current directory %s\nError is: %s\n",directorytocopyto$,Error$(retseq%));
endif

'
'Save a copy of the protocol file to the Epoch folder
if InStr(protFileFullName$,"none") <> 0 then
    'It did not work the other way (ie if InStr()=0)...very strange behavior actually
else
    protcopyfile$ := directorytocopyto$+protFileName$+".prot";
    retprot%:=FileCopy(protFileFullName$,protcopyfile$,0);
endif
if retprot% = 1 then
    PrintLog("Saved a copy of the currently selected protocol file as %s\n\n", protcopyfile$);
else
    PrintLog("Something went wrong copying the protocol file to the current directory %s\nError is: %s\n",directorytocopyto$,Error$(retprot%));
endif

'BURUNGHACK - I commented this out below because the logic is silly
'Save a copy of the stimulus file to the Epoch folder
'if (InStr(stimFileFullName$,"AskMe") <> 0 and InStr(stimFileFullName$,"NoStimFileDesired") <> 0) then
'It did not work the other way (ie if InStr()=0)...very strange behavior actually
'else
'	var sh%:=FileOpen(stimFileFullName$,1);
'    stimcopyfile$ := directorytocopyto$+View(sh%).FileName$(3)+View(sh%).FileName$(4)+View(sh%).FileName$(5);
'	View(sh%);
'	FileClose();
'   retstim%:=FileCopy(stimFileFullName$,stimcopyfile$,0);
'endif
if retstim% = 1 then
    PrintLog("Saved a copy of the currently selected stimulus file as %s\n\n", stimcopyfile$);
else
    PrintLog("Something went wrong copying the stimulus file to the current directory %s\nError is: %s\n",directorytocopyto$,Error$(retstim%));
endif
'
'Save a copy of the master setstim file to the Epoch folder
if (InStr(mastersetstimfile$,"nomastersetstimfile") <> 0)  then
	retmastersetstim% := 1;
else
	var mssh%:=FileOpen(mastersetstimfile$,1);
    mastersetstimcopyfile$ := directorytocopyto$+View(mssh%).FileName$(3)+View(mssh%).FileName$(4)+View(mssh%).FileName$(5);
	View(mssh%);
	FileClose();
    retmastersetstim%:=FileCopy(mastersetstimfile$,mastersetstimcopyfile$,0);
	if retmastersetstim% = 1 then
		PrintLog("Saved a copy of the currently selected master setstim file as %s\n\n", mastersetstimcopyfile$);
	else
		PrintLog("Something went wrong copying the master setstim file to the current directory %s\nError is: %s\n",directorytocopyto$,Error$(retmastersetstim%));
	endif
endif






'
View(currViewCSSTD%);
if retseq% = 1 and retscr% = 1 and retprot% = 1 and retstim% = 1 and retmastersetstim% = 1 then
	return 1; 'allset
else
	PrintLog("Something went wrong copying the Script and/or Sequencer and/or Protocol file to the current directory %s\n",directorytocopyto$);
	return 0;
endif
end
'
func GetStimTime(fnGST$)
var handleGST%,timeGST,retGST%,channels%[MAXCHANSPERFILE%];

timeGST := 0.0;

FilePathSet(stimPath$);
handleGST% := FileOpen(fnGST$,0);
if handleGST%<0 then
    PrintLog("ERROR: Couldn't open file %s.  error is: %s\n",fnGST$,Error$(handleGST%));
else
    retGST%:=ChanList(channels%[]);
    if retGST%=0 then
        PrintLog("ERROR: Stim file %s is of wrong type\n",fnGST$);
    else
        timeGST := Maxtime();
    endif;
    FileClose();
endif;

if timeGST <= 0.0 then
    PrintLog("ERROR: Something went wrong loading the stim\n");
endif;
return timeGST;
end;
'
'
func doSetLoop%()
SetLoop(not qLoop%,qSearching%);
return 1;
end;
'
'
proc SetLoop(lp%,enable%)
if lp%=0 then
    qLoop%:=0;
    ToolbarSet(LOOPSEARCHID%,"Loop this search stim",doSetLoop%);
	ToolbarEnable(SELECTACTIVESTIMSID%,1);
else
    if lp%=1 then
        qLoop%:=1;
        ToolbarSet(LOOPSEARCHID%,"All search stims",doSetLoop%);
		ToolbarEnable(SELECTACTIVESTIMSID%,0);
    else
        PrintLog("ERROR: Bad argument to SetLoop(): %d",lp%);
    endif;
endif;

ToolbarEnable(LOOPSEARCHID%,enable%);

if VERBOSELOG%=1 then PrintLog("qLoop set to %d\n",qLoop%); endif
end;
'
'
func CloseOperantDataCheckWindows%()
const LARGE% := 1000;
var windowList%[LARGE%],i%; 
'
ViewList(windowList%[],2);
for i%:=1 to windowList%[0] do   
    View(windowList%[i%]);	
    if InStr(WindowTitle$(),"<Operant Data Check>") <> 0 then
        FileClose(0,-1);
    endif
next;
'
ToolbarEnable(CLOSEOPCHECKWINID%,0);
'
return 1
'
end
'
func UploadStim(fn$)
if VERBOSELOG%=1 then PL(Print$("In UploadStim:\tTrying to open stim file: %s",fn$)); endif
'
var currStimFileHandle%,numSFchans%,chan%,channels%[MAXCHANSPERFILE%],truncName$,key$,retPWC%,retPWI$,retPWS$,seqTicks,seqTicks%;
var currentPath$,currview%;
var stimData%[audBuffSize%];
ArrConst(stimData%[],0);
var good := 0.0;
'
currentPath$:=FilePath$(); 'take note of the current path
'if (qMC% <> 1) or (MCnumMots%[MCtotnum%] = 1) then
FilePathSet(stimPath$);
'else
'    FilePathSet(MCstimPath$);
'endif;
currview%:=View(); 'take note of the current view handle
currStimFileHandle%:=FileOpen(fn$,0);
if VERBOSELOG%=1 then PrintLog("\nStim File handle to %s is %d, resolution is %g microsecs\n\n",FileName$(), currStimFileHandle%,BinSize()*1000000.0); endif

if currStimFileHandle%<0 then
 	PL(Print$("ERROR:\tCouldn't open stim file %s  | Error is: %s\n",fn$,Error$(currStimFileHandle%)));
else
    View(currStimFileHandle%);
	numSFchans%:=ChanList(channels%[]);
	if numSFchans%=0 then
        PrintLog("ERROR:\tStim file %s is of wrong type\n",fn$);
    else
		if numSFchans% > 1 then
            PrintLog("ERROR: stim file %s has too many chans (%d).\n",fn$,numSFchans%);
        else
			chan% := channels%[1];
			truncName$ := FileName$(3)+FileName$(4);
			key$ := Chr$(Asc(audioPWAKey$)+0);
			stimsz%:=ChanData(chan%,stimData%[],0,MaxTime()); 'load stimulus into array stimData%[]
			Draw(); 'Try to alleviate display hiccup
			retPWC%:=PlayWaveCopy(key$, stimData%[0:stimsz%],0); 'upload data in stimData%[] to playwave area. Makes the display pause updating...
			Draw(); 'Try to alleviate display hiccup
			if retPWC% < 0 then
				PrintLog("ERROR:\tCouldn't add the stim %s to the 1401.  error: %s\n",fn$,Error$(retPWC%));
			else	
				if VERBOSELOG%=1 then PL("In UploadStim:\tStim successfully uploaded to 1401."); endif
				good:=MaxTime(); 'TODO: why get diff song lengths with MaxTime() than with stimtimeSec below??
			endif;
		endif
	endif
endif
'
'calc current stim length in sequencer ticks and load into sequencer
var stimsz;
REALaudioOutRate:=REALaudioOutRate;
stimsz:=stimsz%;
stimtimeSec:=stimsz/REALaudioOutRate;
seqTicks:=stimtimeSec/seqPerMs*1000; 'should give number of seq ticks in curr stim
seqTicks% := seqTicks; 'Convert to integer (is this necessary?)
SampleSeqVar(9,seqTicks%);'send sequencer current stim length in sequencer ticks
var retseqTicks% := SampleSeqVar(9);
var returnedstimtime := retseqTicks% * seqPerMs / 1000;

PrintLog("shouldbeStimtime = %2.6f\n",stimtimeSec);
PrintLog("returnedStimtime = %2.6f\n",returnedstimtime);
'

View(currStimFileHandle%);
FileClose(0);
View(currview%);
return good;
end;
'
'
proc InitializeStimVariables()
'TODO:are we missing any?
ArrConst(stimCodes%[],-1);
ArrConst(stimFileNames$[],"");
ArrConst(stimClasses%[],-1);
ArrConst(stimPctPres[],-1);
ArrConst(stimPctReinf%[],-1);
ArrConst(stimPctTo%[],-1);
ArrConst(searchStimsEnabled%[],-1);
ArrConst(blockStimsEnabled%[],-1);
ArrConst(stimTimes[],-1);
ArrConst(rndplist%[],-1);

end
'
'
proc InitializeSetStimCriterionVariables()
var i%;
ArrConst(ssCriterionReached%[1:],0);
for i% := 1 to numsetstimclasses% do
	ArrConst(lastN%[i%][],0);
next;
ArrConst(lastNIndex%[1:],0);
end
'
'
proc ResetTrialFlags()
qhInTrial% := 0;
qhWaitingToJump% := 0;  
qhWaitingToStartTrial% := 0;
qhWaitingForStimFinish% := 0;
qhWaitingForTrialFinish% := 0;
qhFinishTrial% := 0;
end
'
proc ToolbarState(whichToolbarState$)      

docase
case InStr(whichToolbarState$,"WaitInToolbar") <> 0 then
	ToolbarSet(SOFTREFID%,"Setup Software Referencing",SoftRefSetup%);
	ToolbarEnable(SOFTREFID%,0);
	ToolbarEnable(STOPRECID%,0);
	ToolbarEnable(ADJGAINSID%,0);
	ToolbarEnable(SELECTACTIVESTIMSID%,0);
	ToolbarEnable(CHECKOPERANTDATAID%,0);
	ToolbarEnable(CARID%,0);
	ToolbarEnable(CARCANCELID%,0);
	ToolbarEnable(SESVIEWID%,0);
	ToolbarEnable(QUICKSTART1ID%,1);
	ToolbarEnable(FINISHEXPERIMENTID%,1);
	ToolbarEnable(STARTEPOCHID%,1);
	ToolbarEnable(RESTRTSOMECHANSID%,0);
	ToolbarEnable(LOOPSEARCHID%,0);
	ToolbarSet(PAUSEBLOCKID%,"Pause block",PauseBlock%);
	ToolbarEnable(PAUSEBLOCKID%,0);
	'
case InStr(whichToolbarState$,"StartSampling") <> 0 then
	ToolbarEnable(STARTEPOCHID%,0);
	ToolbarEnable(CARID%,1);
	ToolbarEnable(SOFTREFID%,1);
	ToolbarEnable(SESVIEWID%,1);
	ToolbarEnable(SELECTACTIVESTIMSID%,1);
	ToolbarEnable(STOPRECID%,1);
	ToolbarEnable(QUICKSTART1ID%,0);
	if not qhBehavOnly% then
		ToolbarEnable(RESTRTSOMECHANSID%,1);
		ToolbarEnable(ADJGAINSID%,1);
	endif
case InStr(whichToolbarState$,"StopRecordingStayEpoch") <> 0 then
	ToolbarEnable(STOPRECID%,0);
	ToolbarEnable(RESTRTSOMECHANSID%,0);
	ToolbarEnable(ADJGAINSID%,0);
	ToolbarEnable(SELECTACTIVESTIMSID%,0);
	ToolbarEnable(LOOPSEARCHID%,0);
	ToolbarEnable(CHECKOPERANTDATAID%,0);
	ToolbarSet(PAUSEBLOCKID%,"Pause block",PauseBlock%);
	ToolbarEnable(PAUSEBLOCKID%,0);
else
endcase


end
'
proc ZeroAllFlags()
qSearching%:=0;
qLoop%:=0;
qDoBlocks%:=0;
qSelectRandly%:=0;
qPausedBlock%:=0;
qStopBlock%:=0;
qAskUserBlockParams% := 1;
'
qhInEpoch% := 0;
qhRecordingAndBehavior%:=0;
qhRecordingOnly%:=0;
qhBehavOnly%:=0;
'
qhInTrial% := 0;
'
qhWaitingToJump%:=0;
qhWaitingToStartTrial%:=0;
qhWaitingForStimFinish%:=0;
qhWaitingForTrialFinish%:=0;
qhFinishTrial%:=0;

lastAvailabilityCycleStartMSM%  := -1;
qTrialAvailability% := -1;

var protFileFullName$ := "none";
var stimFileFullName$ := "AskMe";
var mastersetstimfile$ := "nomastersetstimfile";
var currsetstimfile$ := "nocurrsetstimfile";
var currsetstimparamsfile$ := "D:\\experiments\\stimlib\\defaultsetstimsparamsfile.m";

qMC% := 0;
qdosetstims% := 0;
end
'***************************
'***##END## UTILITIES*******
'***************************
'
'***************************
'***#BEGIN# STIM SETUP******
'***************************
'
func SelectNextStim%()
var retMMCS%,randStim,nextStim%;
'
if doCorrectionTrial%=1 then
	nextStim% := lastStim%;
	tmcode%[2] := 1;			'this indicates a correction trial
else
	docase
    case qMC% = 1 then 'we are doing Multicat stimulus type - random at this point, if we want 'search' or 'block' will need to figure that out later
        nextStim% := -1; 'nextStim% = -1 means exemplar concatenation
        retMMCS% := MakeMCStim%();
	case qDoBlocks% then 'pick nextStim% from block playlist
        if qNeedNewBlock% = 1 then
            qNeedNewBlock% := InitBlock%(qAskUserBlockParams%);
            if qNeedNewBlock% = 1 then
                PL("Something went wrong setting up the block");
            else if qNeedNewBlock% = 2 then
                    nextStim%:=-2; 'Block Setup Cancelled
                    return nextStim%;
                endif
            endif
        endif
        blockTrialNum%+=1;
        blockPos%:=blockTrialNum%-1;
        nextStim%:=blockPlaylist%[blockPos%];
        if blockTrialNum% = totBlockTrials% then 'this ends the block
            qStopBlock%:=2; 'will run StopBlock%() without asking user if want to stop
        endif
	case qSearching% then'pick nextStim% from searching playlist (ie list of stims, loop through them
		if not qLoop% then
			repeat
				if searchInd%+1>=numStimFiles% then
					searchInd%:=0;
				else
					searchInd%:=searchInd%+1;
				endif;		
            until searchStimsEnabled%[searchInd%];
			nextStim% := searchInd%;
			if VERBOSELOG%=1 then PL(Print$("In SelectNextStim():\tSearching with stim: %s",stimFileNames$[nextStim%])); endif 
		else
			nextStim% := lastStim%;
			if VERBOSELOG%=1 then PL(Print$("In SelectNextStim():\tLooping with search stim: %s",stimFileNames$[nextStim%])); endif
		endif;
	case qSelectRandly% then
        randStim:=Rand(rndplist%[0],1); 'should return a random number between 1 and the number of rndplist entries
        nextStim%:=rndplist%[Floor(randStim)];
	else
		PL("ERROR: In SelectNextStim():\tWhat stim do you want me to use?!");
        return -3;
	endcase
    'now setup textmarks
    docase
    case qMC% = 1 then
        tmcode%[0]:=MCstimClasses%[MCtotnum%];  'set textmark code 0 to the current stim's code.
        tmcode%[1]:=MCstimClasses%[MCtotnum%];	'set textmark code 1 to the current stim's class.
		tmcode%[2]:=0;                          'set textmark code 2 to '0' since this isn't a correction trial
    case qMC% = 2 then
        tmcode%[0]:=stimCodes%[nextStim%];  	'set textmark code 0 to the current stim's code.
        tmcode%[1]:=stimClasses%[nextStim%];	'set textmark code 1 to the current stim's class.
		tmcode%[2]:=0;                          'set textmark code 2 to '0' since this isn't a correction trial
	else
        tmcode%[0]:=stimCodes%[nextStim%];		'set textmark code 0 to the current stim's code.
        tmcode%[1]:=stimClasses%[nextStim%];    'set textmark code 1 to the current stim's class.
		tmcode%[2]:=0;                          'set textmark code 2 to '0' since this isn't a correction trial
	endcase
endif
'
return nextStim%; 'TODO error checking
end
'
'
func InitBlockBACKUP%()
var initBlockSuccess%:=0;
var blockFiles%[numStimFiles%],numActiveFiles%:=0;
var blockPos%,iIB%,iIB2%,iIB3%,jIB2%,iIB4%,swap1%,swap2%,swapTemp%;

if SelectActiveStims%(blockStimsEnabled%[],"Select Block Stims",1) = 2 then
	return 2; 'Block Setup Cancelled
endif;

'make blockPlaylist below

for iIB% := 0 to numStimFiles%-1 do
	if blockStimsEnabled%[iIB%] then
		blockFiles%[numActiveFiles%]:=iIB%;
		numActiveFiles%:=numActiveFiles%+1;
	endif;
next;

totBlockTrials%:=0;
for iIB2% := 0 to numActiveFiles%-1 do
	for jIB2% := 0 to numBlockRepeats%-1 do
		blockPos% := iIB2%*numBlockRepeats%+jIB2%;
		blockPlaylist%[blockPos%] := blockFiles%[iIB2%];
		totBlockTrials%+=1;
		'PrintLog("item %d is %d\n",pos%+1,blockPlaylist%[pos%]);
    next;
next;
'PrintLog(blockPlaylist%[]);

RecordRandSeed(); 'seeds the random number generator and records the seed value

for iIB3% := 1 to NUMSHUFFLES% do
	swap1% := Trunc(Rand()*numActiveFiles%*numBlockRepeats%);
	swap2% := Trunc(Rand()*numActiveFiles%*numBlockRepeats%);
	swapTemp% := blockPlaylist%[swap1%];
	blockPlaylist%[swap1%] := blockPlaylist%[swap2%];
	blockPlaylist%[swap2%] := swapTemp%;
next;
PL("Block Successfully set up");
ToolbarEnable(SELECTACTIVESTIMSID%,0);
ToolbarEnable(STOPRECID%,0);
ToolbarEnable(PAUSEBLOCKID%,1);
ToolbarEnable(STOPBLOCKID%,1);
PrintLog(toLog$);
PrintLog("\nBlock Playlist (stimcodes):");
for iIB4% := 0 to totBlockTrials%-1 do
	PrintLog("%d,",blockPlaylist%[iIB4%]);
next;
PrintLog("\n\n");
blockNum%+=1;
blockTrialNum%:=0;
initBlockSuccess% := 1;
return not initBlockSuccess%
end
'
'
func InitBlock%(qAskUserBlockParams%)
var initBlockSuccess%:=0;
var blockFiles%[numStimFiles%],numActiveFiles%:=0;
var blockPos%,iIB%,iIB2%,iIB3%,jIB2%,iIB4%,swap1%,swap2%,swapTemp%;

if SelectActiveStims%(blockStimsEnabled%[],"Select Block Stims",1) = 2 then
	return 2; 'Block Setup Cancelled
endif;

'make blockPlaylist below

for iIB% := 0 to numStimFiles%-1 do
	if blockStimsEnabled%[iIB%] then
		blockFiles%[numActiveFiles%]:=iIB%;
		numActiveFiles%:=numActiveFiles%+1;
	endif;
next;

totBlockTrials%:=0;
for iIB2% := 0 to numActiveFiles%-1 do
	for jIB2% := 0 to numBlockRepeats%-1 do
		blockPos% := iIB2%*numBlockRepeats%+jIB2%;
		blockPlaylist%[blockPos%] := blockFiles%[iIB2%];
		totBlockTrials%+=1;
		'PrintLog("item %d is %d\n",pos%+1,blockPlaylist%[pos%]);
    next;
next;
'PrintLog(blockPlaylist%[]);

RecordRandSeed(); 'seeds the random number generator and records the seed value

for iIB3% := 1 to NUMSHUFFLES% do
	swap1% := Trunc(Rand()*numActiveFiles%*numBlockRepeats%);
	swap2% := Trunc(Rand()*numActiveFiles%*numBlockRepeats%);
	swapTemp% := blockPlaylist%[swap1%];
	blockPlaylist%[swap1%] := blockPlaylist%[swap2%];
	blockPlaylist%[swap2%] := swapTemp%;
next;
PL("Block Successfully set up");
ToolbarEnable(SELECTACTIVESTIMSID%,0);
ToolbarEnable(STOPRECID%,0);
ToolbarEnable(PAUSEBLOCKID%,1);
ToolbarEnable(STOPBLOCKID%,1);
PrintLog(toLog$);
PrintLog("\nBlock Playlist (stimcodes):");
for iIB4% := 0 to totBlockTrials%-1 do
	PrintLog("%d,",blockPlaylist%[iIB4%]);
next;
PrintLog("\n\n");
blockNum%+=1;
blockTrialNum%:=0;
initBlockSuccess% := 1;
return not initBlockSuccess%
end
'
func UpdateDialogue%(item%)

var maxtimePerRepeat,mintimePerRepeat,j%,active%:=0,tmpprnt1$,tmpprnt2$;

maxtimePerRepeat:=0.0;
mintimePerRepeat:=0.0;
for j%:=1 to numStimFiles% do
	if DlgValue(j%) then
		active%:=active%+1;
		if qhRecordingAndBehavior% then		
			maxtimePerRepeat:=maxtimePerRepeat+stimTimes[j%]+ITI+RESPWIN+Max(FEED,TIMEOUT);
			mintimePerRepeat:=mintimePerRepeat+stimTimes[j%]+ITI+Min(FEED,TIMEOUT);
		else
			maxtimePerRepeat:=maxtimePerRepeat+stimTimes[j%]+MAXITINO;
			mintimePerRepeat:=mintimePerRepeat+stimTimes[j%]+MINITINO;
		endif;
	endif;
next;
'
var minhours%,minmins%,minsecs%,hours%,mins%,secs%,maxtotalSecs,mintotalSecs;
HoursMinsSecs(maxtimePerRepeat,hours%,mins%,secs%);
HoursMinsSecs(mintimePerRepeat,minhours%,minmins%,minsecs%);
DlgValue$(maxTItemnum%,Print$("Time per repeat:\t\tMin: %02d:%02d:%02d\tMax: %02d:%02d:%02d",minhours%,minmins%,minsecs%,hours%,mins%,secs%));
tmpprnt1$ := Print$("Time per repeat:\t\tMin: %02d:%02d:%02d\tMax: %02d:%02d:%02d",minhours%,minmins%,minsecs%,hours%,mins%,secs%);

maxtotalSecs := DlgValue(rptsItemnum%)*maxtimePerRepeat;
HoursMinsSecs(maxtotalSecs,hours%,mins%,secs%);
mintotalSecs := DlgValue(rptsItemnum%)*mintimePerRepeat;
HoursMinsSecs(mintotalSecs,minhours%,minmins%,minsecs%);
DlgValue$(totTItemnum%,Print$("Total time for %d repeats:\tMin: %02d:%02d:%02d\tMax: %02d:%02d:%02d",DlgValue(rptsItemnum%),minhours%,minmins%,minsecs%,hours%,mins%,secs%));
tmpprnt2$ :=Print$("Total time for %d repeats:\tMin: %02d:%02d:%02d\tMax: %02d:%02d:%02d",DlgValue(rptsItemnum%),minhours%,minmins%,minsecs%,hours%,mins%,secs%);

toLog$ := tmpprnt1$ + "\n" + tmpprnt2$;

return 1;
end;
'
'
func doStopBlock%()
DlgCreate("Stop block? (This will also stop sampling.)");
DlgText("Are you sure you want to stop the block?\n(This will also stop sampling.)",0,0);
DlgButton(0,"No, return to the block.");
DlgButton(1,"Yes, stop the block.");
if DlgShow() then
	qStopBlock%:=1;
	StopBlock%();
endif
return 1;
end;
'
func StopBlock%()
'
docase
case qStopBlock% = 1 then 'premature block stoppage
	PL(Print$("Prematurely stopping the block after %d of %d trials at the user's request.",blockTrialNum%,totBlockTrials%));
case qStopBlock% = 2 then 'normal block stopping once all trials have been run
	PL(Print$("Block finished. %d repeats of %d stimuli;  %d of %d trials run. Stopping Recording",numBlockRepeats%,totBlockTrials%/numBlockRepeats%,blockTrialNum%,totBlockTrials%));
else
	WarnDlg("How did you get inside StopBlock%() if qStopBlock% doesn't equal 1 or 2?","How did you get inside stopblock if qStopBlock% doesn't equal 1 or 2?");
	PL("How did you get inside StopBlock%() if qStopBlock% doesn't equal 1 or 2?");
	'TODO: now what??
endcase
'
View(datahandle%).FileComment$(3,Print$("Block run. %d repeats of %d stimuli.  %d of %d trials run.",numBlockRepeats%,totBlockTrials%/numBlockRepeats%,blockTrialNum%,totBlockTrials%));
qPausedBlock%:=0;
'
StopRecordingandSave%(1);
qStopBlock% := 0;
'
return 1;
end;
'
func PauseBlock%()
qPausedBlock%:=1;
ToolbarSet(PAUSEBLOCKID%,"Resume block",ResumeBlock%);
ToolbarEnable(PAUSEBLOCKID%,1);
PL("Pausing the block.");
return 1;
end;
'
func ResumeBlock%()
qPausedBlock%:=0;
ToolbarSet(PAUSEBLOCKID%,"Pause block",PauseBlock%);
ToolbarEnable(PAUSEBLOCKID%,1);
PL("Resuming the block.");
return 1;
end;
'
'
func MakeMCStim%()
var MCsuccess%:=1;
var currnumMots%:=0;
var currnumClassOne%,currnumClassTwo%,currnumClassThree%;
var currExemplar%;
var leftvsright%:=0,havegoodstimulus%:=0;
var retFSAMC%,retMCCS%;
var currrnd;
var exemplarfilehandle%,MCouthandle%;
var toconcatexemplarcodes%[MAXSTIMS%],toconcatexemplarnames$[MAXSTIMS%];
var currViewMMC%,currFilePathMMC$;
currViewMMC% := View();
currFilePathMMC$ := FilePath$();
'1. pick nummots
'2. while loop with num from each class counter, pick random value from playlist and update stuff
'3. calculate class of proposed stimulus, then make sure it's allowed (eg: MCallowambig%)
'4. do the concatenation (somehow...)
MCtotnum% := MCtotnum% + 1;
MCnumMots%[MCtotnum%] := Floor(Rand(MCmaxnummots%-MCminnummots%+1,MCminnummots%));
while havegoodstimulus% = 0 do
    currnumMots%:=0;
    currnumClassOne%:=0;
    currnumClassTwo%:=0;
    currnumClassThree%:=0;
    while currnummots% < MCnumMots%[MCtotnum%] do
        currrnd := Rand(rndplist%[0],1);
        currExemplar% := Floor(currrnd);
        currExemplar% := rndplist%[currExemplar%];
        docase
        case stimClasses%[currExemplar%] = 1 then
            if (currnumClassTwo% > 0) and (MCallowLR% <> 1) then
                if VERBOSELOG%=1 then PL(Print$("already have a class 2 exemplar and MCallowLR%=0, skipping this class 1 exemplar")); endif
            else
                if currnumClassOne% < MCclassoneMaxnummots% then
                    currnumMots% := currnumMots% + 1;
                    currnumClassOne% := currnumClassOne% + 1;
                    toconcatexemplarcodes%[currnumMots%] := stimCodes%[currExemplar%];
                    toconcatexemplarnames$[currnumMots%] := stimFileNames$[currExemplar%];
                else
                    if VERBOSELOG%=1 then PL(Print$("already have enough class 1 exemplars, skipping this exemplar")); endif
                endif
            endif
        case stimClasses%[currExemplar%] = 2 then
            if (currnumClassOne% > 0) and (MCallowLR% <> 1) then
                if VERBOSELOG%=1 then PL(Print$("already have a class 1 exemplar and MCallowLR%=0, skipping this class 2 exemplar")); endif
            else
                if currnumClassTwo% < MCclasstwoMaxnummots% then
                    currnumMots% := currnumMots% + 1;
                    currnumClassTwo% := currnumClassTwo% + 1;
                    toconcatexemplarcodes%[currnumMots%] := stimCodes%[currExemplar%];
                    toconcatexemplarnames$[currnumMots%] := stimFileNames$[currExemplar%];
                else
                    if VERBOSELOG%=1 then PL(Print$("already have enough class 2 exemplars, skipping this exemplar")); endif
                endif
            endif
        case stimClasses%[currExemplar%] = 3 then
            if currnumClassThree% < MCclassthreeMaxnummots% then
                currnumMots% := currnumMots% + 1;
                currnumClassThree% := currnumClassThree% + 1;
                toconcatexemplarcodes%[currnumMots%] := stimCodes%[currExemplar%];
                toconcatexemplarnames$[currnumMots%] := stimFileNames$[currExemplar%];
            else
                if VERBOSELOG%=1 then PL(Print$("already have enough class 2 exemplars, skipping this exemplar")); endif
            endif 
        else
            PrintLog("I don't know what to do with a stimulus class of %d.\nSomething's wrong with your protocol file. Halting Script.\n",stimClasses%[currExemplar%]);
            WarnDlg("Found a bad stimulus class, halting Script.","Found a bad stimulus class, something's wrong with your protocol file.\nHalting Script.");
            Debug();
            'halt;
        endcase        
    wend
    'Now check class of proposed MC stim
    currnumMots% := 0;
    leftvsright% := 0;
    if MCnumMots%[MCtotnum%] = 1 then
        currnumMots% := 1;
        MCstimClasses%[MCtotnum%] := stimClasses%[currExemplar%];
        MCstimFilenames$[MCtotnum%] := stimFileNames$[currExemplar%];
    else
        leftvsright% := currnumClassOne% - currnumClassTwo%;
        '        while currnummots% < MCnumMots%[MCtotnum%] do
        '            docase
        '            case stimClasses%[toconcatexemplarcodes%[currnumMots%]] = 1 then
        '                leftvsright% := leftvsright% + 1;
        '            case stimClasses%[toconcatexemplarcodes%[currnumMots%]] = 2 then
        '                leftvsright% := leftvsright% - 1;                
        '            else
        '            endcase
        '            currnumMots% := currnumMots% +1;
        '        wend
        if VERBOSELOG%=1 then PL(Print$("leftvsright% is: %d",leftvsright%)); endif
        docase
        case leftvsright% > 0 then
            MCstimClasses%[MCtotnum%] := 1;
        case leftvsright% < 0 then
            MCstimClasses%[MCtotnum%] := 2;
        else
            MCstimClasses%[MCtotnum%] := 3;
        endcase
    endif
    
    if (MCstimClasses%[MCtotnum%] = 3) and (MCallowambig% = 0) then
        havegoodstimulus% := 0;
    else
        havegoodstimulus% := 1;
    endif
wend
'Now we have a good stimulus, do the actual stimulus concatenation (here or in uploadstim()?)
'HERE!
if MCnumMots%[MCtotnum%] <> 1 then
    FilePathSet(stimPath$);
    for currExemplar% := 1 to MCnumMots%[MCtotnum%] do
        exemplarfilehandle% := FileOpen(toconcatexemplarnames$[currExemplar%],0,0);
        if currExemplar% = 1 then
            MCstimFilenames$[MCtotnum%] := FileName$(3)+FileName$(4);
            MCouthandle%:=FileNew(7,0,View(exemplarfilehandle%).Binsize()*1e6,1,0.001); 'Create new file
            View(exemplarfilehandle%);
            retMCCS% := ChanSave(1, 1, MCouthandle%);
        else
            MCstimFilenames$[MCtotnum%] := MCstimFilenames$[MCtotnum%] + "+" + FileName$(3)+FileName$(4);
            View(exemplarfilehandle%);
            retMCCS% := ChanSave(1, 1, MCouthandle%,0.0,View(exemplarfilehandle%).MaxTime(),View(MCouthandle%).MaxTime());
        endif
        '
        View(exemplarfilehandle%);
        FileClose(0,-1);
        if retMCCS% < 0 then
            MCsuccess% := 0;
            return MCsuccess%;
        endif
    next
    View(MCouthandle%);
    'FilePathSet(MCstimPath$,0,1);
    FilePathSet(stimPath$);
    MCstimFilenames$[MCtotnum%] := MCstimFilenames$[MCtotnum%] + datafileextension$;
    retFSAMC% := FileSaveAs(MCstimFilenames$[MCtotnum%],-1,1);
    if retFSAMC% <> 0 then
        WarnDlg("Something went wrong saving the MC stim","Something went wrong saving the MC stim");
        MCsuccess% := 0;
    endif
    FileClose(0,-1);
endif
'
View(currViewMMC%);
FilePathSet(currFilePathMMC$);
'
return MCsuccess%;
end
'
func SSNeedNewStimulusSet%(&trialoutcome%[],&ssCriterionCorrect%[],&ssCriterionReached%[],&lastN%[][],&lastNIndex%[])
'
var i%;
var neednewset% := 0;
if trialoutcome%[2] = 0 then 'don't do any of this for correction trials
	neednewset% := 1;
	var currclass% := trialoutcome%[1];
	lastN%[currclass%][lastNIndex%[currclass%]] := trialoutcome%[0];
	'
	'see if we've reached criterion for a given class
	var checksum% := 0;
	for i% := 0 to ssCriterionLength% - 1 do
		if lastN%[currclass%][i%] = 1 then
			checksum% += 1;
		endif
	next;
	if checksum% >= ssCriterionCorrect%[currclass%] then
		ssCriterionReached%[currclass%] := 1;
	endif
	'
	'increment the trial counter for the current class or reset it to 0
	if lastNIndex%[currclass%] = ssCriterionLength% - 1 then
		lastNIndex%[currclass%] := 0;
	else
		lastNIndex%[currclass%] += 1;
	endif
	'
	'check for overall criterion met 
	for i% := 1 to ssCriterionReached%[0] do
		if ssCriterionReached%[i%] <> 1 then
			if  ssCriterionCorrect%[i%] <> 0 then 'skip classes which require no correct trials
				neednewset% := 0;
			endif
		endif
	next;
	'
endif
'
return neednewset%;
end
'
func SSSetupStimulusSet$(mastersetstimfile$,useoldset%)   'neednewset
var SSScurrview% := View();
'
var subinfoalreadyopen%:=1;
if subjectInfoHandle% < 0 then
	subinfoalreadyopen% := 0;
	subjectInfoHandle%:=FileOpen(subjectInfoName$,8,2);
endif
'
if useoldset% <> 2 then
	var stillneedset% := 1;
	if useoldset% = 1 then    'neednewset=0
		stillneedset% := 0;
		'Here check to see if there's already a setstimfile in the subjectinfo - if not, then look in the stim folder for one, add it to the subjectinfo list and use it		
		if InStr(currsetstimfile$,"nocurrsetstimfile") = 0 then    'have one, check if it matches
			if numfoundcurrsetstimfiles% = 1 then'have exactly one foundcurrsetstimfiles$
				if InStr(currsetstimfile$,foundcurrsetstimfiles$[0]) = 1 and Len(currsetstimfile$) = Len(foundcurrsetstimfiles$[0]) then'currsetstimfile$ matches the single foundsetstimfile then use it without updating the subject info file
					currsetstimfile$ := foundcurrsetstimfiles$[0];
				else 'the found one takes precedence (as it was likely imported from ndege - use it and document in the subjectinfo file
					currsetstimfile$ := foundcurrsetstimfiles$[0];
					setstimNum% := setstimNum% + 1;	
					View(subjectInfoHandle%).Print("\n---------------\n");
					View(subjectInfoHandle%).Print("\n\"%s\",\"NewSetStimFile\",\"%s\",%d,\n",GetTimeStamp$(),currsetstimfile$,setstimNum%);
					View(subjectInfoHandle%).FileSave();
				endif
			else
				if  numfoundcurrsetstimfiles% < 1 then
					'use currsetstimfile$ found in subjectinfo file (ie don't do anything differently)
				else
					WarnDlg("found more than one *.currsetstim","found more than one *.currsetstim\nFix this!\nHALTING!");
					halt;
				endif
			endif
		else  'nosetstimfile found in subjectinfofile
			if numfoundcurrsetstimfiles% = 1 then'have exactly one foundcurrsetstimfiles$ - use it!
				currsetstimfile$ := foundcurrsetstimfiles$[0];
			else
				if numfoundcurrsetstimfiles% < 1 then
					'dont have a set from subject info or from folder, need to make a new one
					stillneedset% := 1;
				else
					WarnDlg("found more than one *.currsetstim","found more than one *.currsetstim\nFix this!\nHALTING!");
					halt;
				endif
			endif
		endif
	endif
	
	if stillneedset% = 1 then 'need to make new set here
		currsetstimfile$ := stimPath$ + "setstims" + "_" + GetTimeStamp$() + ".currsetstim";
		var fromML$;
		MatLabOpen();
		MatLabShow(1);
		var mle% := MatLabEval("addpath(pathdef);",fromML$);
		MatLabEval("RandStream.setDefaultStream(RandStream('mt19937ar','seed',sum(100*clock)));");
		MatLabEval("success = -1");
		MatLabPut("masterfilename",mastersetstimfile$);
		MatLabPut("paramsfile",currsetstimparamsfile$);
		MatLabPut("newsetstimfile",currsetstimfile$);
		MatLabEval("setstims = SM_SS_readsetstimfile(masterfilename)");
		MatLabEval("run(paramsfile)");
		MatLabEval("newsetstims = SM_SS_pickengagedset([],setstims,params)");
		MatLabEval("success = SM_SS_writeS2setstimsstimfile(newsetstims,newsetstimfile)");
		var successfromML%;
		MatLabGet("success",successfromML%);
		if successfromML% <> 1 then
			Message("Investigate Error in Matlab - When Satisfied, click 'ok'");
		else
			setstimNum% := setstimNum% + 1;	
			View(subjectInfoHandle%).Print("\n---------------\n");
			View(subjectInfoHandle%).Print("\n\"%s\",\"NewSetStimFile\",\"%s\",%d,\n",GetTimeStamp$(),currsetstimfile$,setstimNum%);
			View(subjectInfoHandle%).FileSave();
			
			if 	numfoundcurrsetstimfiles% > 0 then    'need to rename
				var retFC%,i%;			
				for i% := 0 to numfoundcurrsetstimfiles%-1 do
					var newname$;				
					newname$ := Left$(foundcurrsetstimfiles$[i%],Len(foundcurrsetstimfiles$[i%])-12) + ".stim";
					retFC% := FileCopy(foundcurrsetstimfiles$[i%],newname$);
					if retFC% = 1 then
						FileDelete(foundcurrsetstimfiles$[i%]);
					else
						PrintLog("WARNING: wasn't able to rename %s. Error: %s",foundcurrsetstimfiles$[i%],Error$(retFC%));
					endif
				next
			endif			
			
			
		endif
		MatLabClose();
		'
		
		
		if subinfoalreadyopen% <> 1 then
			View(subjectInfoHandle%);
			FileClose();
			subjectInfoHandle% := -1;		
		endif		
	endif
	' 	
else
	currsetstimfile$ := stimFileFullName$;
endif
'
View(SSScurrview%);
return currsetstimfile$;
end
'
proc UpdateMasterSetStimFile(trialoutcome%[])
var currview% := View();
var mssinhandle% := FileOpen(mastersetstimfile$,1);
if mssinhandle% < 0 then
	PrintLog("cannot open master setstimfile, halting.");
	Message("cannot open master setstimfile, halting.");
	halt
endif

var mssouthandle% := FileNew(1,0);

View(mssinhandle%);
MoveTo(0,0,1);
'
var readmore% := 1,readret%;
var msssname$,dum$,mssclass%,msspresfreq%,mssnumT%,mssnumC%,mssnumI%,mssnumN%,mssCurrSet%;
ReadSetup(",","\t");
while readmore% > 0 do'read through all the header info
	readret% := read(msssname$,mssclass%,msspresfreq%,mssnumT%,mssnumC%,mssnumI%,mssnumN%,mssCurrSet%);
	'readret% := read(msssname$,dum$,mssclass%,dum$,msspresfreq%,dum$,mssnumT%,dum$,mssnumC%,dum$,mssnumI%,dum$,mssnumN%,dum$,mssCurrSet%);
	if readret% < 0 then
		if VERBOSELOG%=1 then 
			PrintLog("Got to end of mastersetstim file\n");
		endif
		break;
	endif   
	var addcorrect% := 0,addincorrect%:=0,addnoresponse%:=0;
	docase
	case trialoutcome%[0] = 0 then
		addcorrect% := 0;
		addincorrect% := 1;
		addnoresponse% := 0;
	case trialoutcome%[0] = 1 then
		addcorrect% := 1;
		addincorrect% := 0;
		addnoresponse% := 0;
	case trialoutcome%[0] = 2 then
		addcorrect% := 0;
		addincorrect% := 0;
		addnoresponse% := 1;
	endcase
	
	
	var mssstiminset%:=0,i%;
	if InStr(Left$(msssname$,Len(msssname$)-4),Left$(stimFileNames$[currStim%],Len(stimFileNames$[currStim%])-4)) <> 0  then    'find the right line 
		View(mssouthandle%).Print("\"%s\",\t%d,\t%d,\t%d,\t%d,\t%d,\t%d,\t%d\n",msssname$,stimClasses%[currStim%],msspresfreq%,mssnumT%+1,mssnumC%+addcorrect%,mssnumI%+addincorrect%,mssnumN%+addnoresponse%,1);
	else   'EWWWW SO HACKY
		mssstiminset%:=0;
		for i% := 0 to numStimFiles% - 1 do
			if InStr(Left$(msssname$,Len(msssname$)-4),Left$(stimFileNames$[i%],Len(stimFileNames$[i%])-4)) <> 0 then
				mssstiminset% := 1;
				break;
			endif
		next;			
		'
		View(mssouthandle%).Print("\"%s\",\t%d,\t%d,\t%d,\t%d,\t%d,\t%d,\t%d\n",msssname$,mssclass%,msspresfreq%,mssnumT%,mssnumC%,mssnumI%,mssnumN%,mssstiminset%);
	endif
wend

View(mssinhandle%);
FileClose();
View(mssouthandle%);
FileSaveAs(mastersetstimfile$,1,1);
FileClose();
ReadSetup();
View(currview%);
end
'
proc UpdateMasterSetStimFileUTtoT()
var currview% := View();
var mssinhandle% := FileOpen(mastersetstimfile$,1);
if mssinhandle% < 0 then
	PrintLog("cannot open master setstimfile, halting.");
	Message("cannot open master setstimfile, halting.");
	halt
endif

var mssouthandle% := FileNew(1,0);

View(mssinhandle%);
MoveTo(0,0,1);
'
var readmore% := 1,readret%;
var msssname$,dum$,mssclass%,msspresfreq%,mssnumT%,mssnumC%,mssnumI%,mssnumN%,mssCurrSet%;
ReadSetup(",","\t");
while readmore% > 0 do'read through all the header info
	readret% := read(msssname$,mssclass%,msspresfreq%,mssnumT%,mssnumC%,mssnumI%,mssnumN%,mssCurrSet%);
	'readret% := read(msssname$,dum$,mssclass%,dum$,msspresfreq%,dum$,mssnumT%,dum$,mssnumC%,dum$,mssnumI%,dum$,mssnumN%,dum$,mssCurrSet%);
	if readret% < 0 then
		if VERBOSELOG%=1 then 
			PrintLog("Got to end of mastersetstim file\n");
		endif
		break;
	endif 
	var i%;
	for i% := 0 to numStimFiles% - 1 do
		if InStr(Left$(msssname$,Len(msssname$)-4),Left$(stimFileNames$[i%],Len(stimFileNames$[i%])-4)) <> 0 then
			if mssclass% = 5 then
				mssclass% := 3;
			else
				if mssclass% = 6 then
					mssclass% := 4;
				endif
			endif
			break;
		endif
	next;			
	'
	View(mssouthandle%).Print("\"%s\",\t%d,\t%d,\t%d,\t%d,\t%d,\t%d,\t%d\n",msssname$,mssclass%,msspresfreq%,mssnumT%,mssnumC%,mssnumI%,mssnumN%,mssCurrSet%);
	'
wend

View(mssinhandle%);
FileClose();
View(mssouthandle%);
FileSaveAs(mastersetstimfile$,1,1);
FileClose();
ReadSetup();
View(currview%);
end
'
'
'***************************
'***##END## STIM SETUP******
'***************************